Below is a beginner-friendly, â€œbuild-it-as-you-goâ€ walkthrough followed by the complete function.
Feel free to run each numbered cell in an interactive Python session (Jupyter, VS Code, or IDLE) to see whatâ€™s happening at every step.


---

1. Imports youâ€™ll need

# 1ï¸âƒ£  Core libraries
from pathlib import Path      # modern, object-oriented file paths
import shutil                 # for copying files
from typing import List       # for type hints (optional)


---

2. Gather every file under the source folder (recursively)

# 2ï¸âƒ£  Replace this with your own folder
SRC_ROOT = Path(r"C:\path\to\source")

all_files = [p for p in SRC_ROOT.rglob("*") if p.is_file()]
print(f"Found {len(all_files)} files")

Path.rglob("*") walks all sub-directories automatically.
You should now see how many files were detected.


---

3. Keep only files whose names contain one (or more) keywords

# 3ï¸âƒ£  Define ANY keywords you want to match in the filename
keywords = ["sales", "report", "2025"]

def has_keyword(path: Path, kw_list: List[str], case_sensitive=False) -> bool:
    name = path.name if case_sensitive else path.name.lower()
    kws  = kw_list         if case_sensitive else [k.lower() for k in kw_list]
    return any(kw in name for kw in kws)

filtered = [f for f in all_files if has_keyword(f, keywords)]
print(f"Matched {len(filtered)} files with keywords {keywords}")


---

4. Pick the most recently modified file from the filtered list

# 4ï¸âƒ£  Use the fileâ€™s â€œlast-modifiedâ€ timestamp
latest_file = max(filtered, key=lambda p: p.stat().st_mtime, default=None)

if latest_file is None:
    raise FileNotFoundError("No files matched the given keywords.")
print(f"Newest file is: {latest_file}")


---

5. Copy it to the destination folder

# 5ï¸âƒ£  Destination directory (will be created if missing)
DST_DIR = Path(r"C:\path\to\destination")
DST_DIR.mkdir(parents=True, exist_ok=True)

# Preserve original filename and metadata
copied_to = DST_DIR / latest_file.name
shutil.copy2(latest_file, copied_to)

print(f"Copied â†’ {copied_to}")


---

6. (Optional) Keep only the N most recent files in the destination

def prune_destination(dest: Path, keep_last: int = 3):
    files = sorted(
        [p for p in dest.iterdir() if p.is_file()],
        key=lambda p: p.stat().st_mtime,
        reverse=True,
    )
    for old in files[keep_last:]:
        old.unlink()          # permanently delete
        print(f"Deleted old backup: {old}")

# Uncomment if you want this behaviour
# prune_destination(DST_DIR, keep_last=3)


---

7. Full function

Hereâ€™s the same logic wrapped in one tidy, reusable function:

from pathlib import Path
import shutil
from typing import List, Optional

def copy_latest_file(
    src_root: str | Path,
    dst_dir: str | Path,
    keywords: List[str],
    case_sensitive: bool = False,
    keep_last: Optional[int] = None,
) -> Path:
    """
    Find the newest file under `src_root` whose *filename* contains ANY of
    the given `keywords`, copy it into `dst_dir`, and (optionally) keep only
    the last `keep_last` files in that destination.

    Returns the Path of the copied file.
    """
    src_root = Path(src_root)
    dst_dir  = Path(dst_dir)
    dst_dir.mkdir(parents=True, exist_ok=True)

    # 1. Find all matching files
    matches = [
        p for p in src_root.rglob("*") if p.is_file()
        and (
            (set(k if case_sensitive else k.lower() for k in keywords)
             & {p.name}  # dummy to force evaluation
             or any((k if case_sensitive else k.lower()) in
                    (p.name if case_sensitive else p.name.lower())
                    for k in keywords))
        )
    ]
    if not matches:
        raise FileNotFoundError("No file found with the specified keywords.")

    # 2. Choose the newest
    latest = max(matches, key=lambda p: p.stat().st_mtime)

    # 3. Copy it
    dest_path = dst_dir / latest.name
    shutil.copy2(latest, dest_path)

    # 4. Optionally prune old copies
    if keep_last is not None:
        files = sorted(
            [f for f in dst_dir.iterdir() if f.is_file()],
            key=lambda p: p.stat().st_mtime,
            reverse=True,
        )
        for old in files[keep_last:]:
            old.unlink()

    return dest_path

Usage

dest = copy_latest_file(
    src_root=r"C:\Data",
    dst_dir=r"C:\Backup\Daily",
    keywords=["sales", ".xlsx"],
    keep_last=3,            # omit or set to None if you donâ€™t want pruning
)
print("Latest file copied to:", dest)


---

Why this design is beginner-friendly

1. Pathlib everywhere â€“ no back-slash headaches, clear methods (rglob, stem, suffix, etc.).


2. Step-by-step build â€“ run each section, inspect variables, gain confidence.


3. Plain English docstring & comments â€“ quickly recall what each piece does.


4. Optional clean-up â€“ copy-paste the function even if you donâ€™t need the pruning part.



You can now adapt the keyword list, source/destination folders, or the retention rule with a single line change. Happy coding!

Absolutely! Let's start from the very basics, so you understand what a function is, how it works, and how to build up gradually to a more complex one.


---

ðŸ”¹ What is a Python Function?

A function is like a recipe. You give it some ingredients (called inputs or arguments), and it gives you a result (called output or return value).


---

âœ… Step 1: Your First Function (Simple Addition)

def add_numbers(a, b):
    result = a + b
    return result

Explanation:

def means you're defining a function.

add_numbers is the name of the function.

a, b are inputs.

a + b adds the numbers.

return result gives the output.


Try it:

print(add_numbers(2, 3))  # Output: 5


---

âœ… Step 2: Add a Message (More Friendly Output)

def greet_user(name):
    print("Hello, " + name + "!")

greet_user("Sohan")  # Output: Hello, Sohan!


---

âœ… Step 3: A Function with Decision Making (if-else)

def check_even_or_odd(number):
    if number % 2 == 0:
        return "Even"
    else:
        return "Odd"

print(check_even_or_odd(4))  # Output: Even
print(check_even_or_odd(7))  # Output: Odd


---

âœ… Step 4: A Slightly Complex One â€“ Average of List

def calculate_average(numbers):
    total = sum(numbers)
    count = len(numbers)
    average = total / count
    return average

my_list = [10, 20, 30, 40]
print(calculate_average(my_list))  # Output: 25.0


---

âœ… Step 5: Final: Build a Custom Function Together

Letâ€™s say you want to:

Take a list of numbers.

Remove any negative numbers.

Square the remaining numbers.

Return the result.


def process_numbers(numbers):
    clean_numbers = []
    for num in numbers:
        if num >= 0:
            clean_numbers.append(num ** 2)
    return clean_numbers

sample = [1, -2, 3, -4, 5]
print(process_numbers(sample))  # Output: [1, 9, 25]


---

Would you like to now:

1. Try writing a function yourself and Iâ€™ll guide you?


2. Move to more complex logic like working with files, charts, or APIs?


3. Build something fun like a number guessing game or calculator?



Let me know your goal!




Below is a mini-lesson you can run step-by-step.
Each step adds one small idea; run it, inspect the output, and move on.
At the end youâ€™ll see the same pieces put together as one tidy function.


---

0.  Imports weâ€™ll need

from pathlib import Path        # modern, OS-independent path handling
import shutil                   # for copying files
import time                     # only for pretty-printing timestamps in this demo


---

1.  Point to your folders

# ðŸ‘‰ Change these to match your machine
SRC_DIR = Path(r"C:\Data\Reports")     # search starts here (all sub-folders included)
DST_DIR = Path(r"C:\Data\Latest")      # where the newest file will be copied

# Make sure the destination exists
DST_DIR.mkdir(parents=True, exist_ok=True)

Why Path instead of plain strings?
Path objects work the same on Windows, macOS, and Linux and give you handy methods like .rglob().


---

2.  Find all files under SRC_DIR

all_files = [f for f in SRC_DIR.rglob("*") if f.is_file()]
print(f"Found {len(all_files)} files")

What just happened?

.rglob("*") walks every sub-folder.

f.is_file() keeps regular files and skips directories.



---

3.  Filter by a keyword (or several)

KEYWORDS = ["sales", "2025"]   # match files whose *names* contain BOTH words

def name_has_keywords(path, keywords):
    name_lower = path.name.lower()
    return all(k.lower() in name_lower for k in keywords)

matching_files = [f for f in all_files if name_has_keywords(f, KEYWORDS)]
print(f"{len(matching_files)} files match {KEYWORDS}")

(Change the words or add more to get the filter you need.)


---

4.  Pick the most recently modified one

latest = max(matching_files, key=lambda f: f.stat().st_mtime)
print("Latest file:", latest.name)
print("Modified:", time.ctime(latest.stat().st_mtime))

.stat().st_mtime returns the epoch time (seconds since 1970-01-01).
max(..., key=...) grabs the path whose timestamp is greatest.


---

5.  Copy it to the destination

destination_path = DST_DIR / latest.name          # keep the same file name
shutil.copy2(latest, destination_path)            # copy2 preserves timestamps
print("Copied to:", destination_path)

Thatâ€™s the whole workflow in bite-size pieces.
Once each cell behaves as expected, youâ€™re ready for the one-shot function ðŸ‘‡.


---

6.  The full beginner-friendly function

from pathlib import Path
import shutil

def copy_latest_file(src_dir, dst_dir, keywords):
    """
    Search `src_dir` (incl. sub-folders) for the newest file whose *name*
    contains *all* `keywords` (case-insensitive).  Copy it into `dst_dir`
    and return the destination Path.

    Example
    -------
    copy_latest_file(
        r"C:\Data\Reports",                # source tree
        r"C:\Data\Latest",                 # destination folder
        keywords=["sales", "2025"]         # words that must appear in the file name
    )
    """
    src_dir = Path(src_dir)
    dst_dir = Path(dst_dir)
    dst_dir.mkdir(parents=True, exist_ok=True)

    # Collect candidate files
    def match(p):
        name = p.name.lower()
        return all(k.lower() in name for k in keywords)

    matches = [p for p in src_dir.rglob("*") if p.is_file() and match(p)]
    if not matches:
        raise FileNotFoundError(f"No files containing {keywords} found under {src_dir}")

    # Latest by modification time
    latest = max(matches, key=lambda p: p.stat().st_mtime)

    # Copy it
    target = dst_dir / latest.name
    shutil.copy2(latest, target)   # use copy2 to preserve metadata
    return target

How to use it

new_file = copy_latest_file(
    src_dir=r"C:\Data\Reports",
    dst_dir=r"C:\Data\Latest",
    keywords=["sales", "2025"]
)
print("âœ… Copied:", new_file)


---

What if I need to keep only the last N files in the destination?

Add two lines at the end of the function:

# --- optional clean-up: keep only N most recent files in dst_dir ---
    N = 3
    existing = sorted(dst_dir.glob("*"), key=lambda p: p.stat().st_mtime, reverse=True)
    for old in existing[N:]:
        old.unlink()                      # delete anything older than the N freshest


---

Why these libraries?

Library	Why we picked it

pathlib	Clear, cross-platform paths
shutil	Easy, reliable file copy
time	Only for human-readable timestamp printing in demos


Everything is in the Python standard libraryâ€”no extra installs required.
Happy automating!



Hereâ€™s a drop-in replacement for your current find_latest_file_and_copy that adds keyword filtering while staying almost identical to the code youâ€™re already running.

import os
import shutil
from pathlib import Path
from typing import List, Union, Sequence

def find_latest_file_and_copy(
    source_dirs: Union[str, Path, Sequence[Union[str, Path]]],
    destination_dir: Union[str, Path],
    keywords: List[str] | None = None,
    case_sensitive: bool = False,
) -> Path:
    """
    Look through one *or* many source folders (recursively), find the most
    recently-modified file whose **name** contains ANY of `keywords`, and copy
    it to `destination_dir`.

    Parameters
    ----------
    source_dirs      : str | Path | list/tuple
        A single directory *or* an iterable of directories to search.
    destination_dir  : str | Path
        Where the newest matching file will be copied.
    keywords         : list[str] | None
        Text snippets to look for in the filename. If None or empty, every
        file counts.
    case_sensitive   : bool
        Match keywords with or without case-sensitivity.

    Returns
    -------
    pathlib.Path
        The full path of the file that was copied.
    """
    # ---- normalise inputs ---------------------------------------------------
    if isinstance(source_dirs, (str, Path)):
        source_dirs = [source_dirs]

    dest = Path(destination_dir)
    dest.mkdir(parents=True, exist_ok=True)

    # ---- keyword pre-processing --------------------------------------------
    if keywords:
        kws = keywords if case_sensitive else [k.lower() for k in keywords]
    else:
        kws = []   # treat as "no filtering"

    # ---- search for newest matching file ------------------------------------
    latest_file      = None
    latest_file_mtime = 0

    for src in source_dirs:
        for root, _, files in os.walk(src):
            for file in files:
                # â‘  keyword filter
                name_to_check = file if case_sensitive else file.lower()
                if kws and not any(kw in name_to_check for kw in kws):
                    continue  # skip non-matches

                # â‘¡ compare modification time
                file_path = os.path.join(root, file)
                try:
                    mtime = os.path.getmtime(file_path)
                except OSError:
                    continue  # ignore unreadable files

                if mtime > latest_file_mtime:
                    latest_file_mtime  = mtime
                    latest_file        = file_path

    # ---- copy result (if found) ---------------------------------------------
    if latest_file is None:
        raise FileNotFoundError("No file matched the given keywords.")

    dest_path = dest / Path(latest_file).name
    shutil.copy2(latest_file, dest_path)  # copy2 keeps timestamps/metadata
    print(f"Copied '{latest_file}'  â†’  '{dest_path}'")

    return dest_path


---

How to call it

# One directory
find_latest_file_and_copy(
    source_dirs=r"\\ent.wfb.bank.corp\WHLSDFS\Shared\Agency Services\Daily Reports",
    destination_dir=r"C:\Backups\Daily",
    keywords=["wip", "report"],   # match ANY of these
    case_sensitive=False,         # ignore case (default)
)

# Many directories
sources = [
    r"\\...Financial Cash Controls\...\2025",
    r"\\...Agency Servicing\VIP\ARCOE Recons\ATI 1007201",
    r"\\...MCCY Recon\2025",
]
find_latest_file_and_copy(
    source_dirs=sources,
    destination_dir=r"C:\Backups\Daily",
    keywords=[".xlsx", "wip"],     # e.g. only Excel WIP files
)

What changed compared to your original snippet?

Feature	Old version	New version

Keyword filter	âœ˜	âœ” keywords argument, case-toggle
Multiple source roots	âœ˜ (single)	âœ” source_dirs accepts list / tuple
Pathlib for destination	partial	full use for mkdir & return value
Type hints / docstring	minimal	expanded, beginner-friendly


Copy the function into your script/notebook, adjust the call as shown, and youâ€™re done. Let me know if youâ€™d like any extra tweaks (e.g. keeping only the last N backups in the destination).

What went wrong?
The | (pipe) syntax for â€œA or Bâ€ type hints only works in Python 3.10+.
Your notebook/kernel is on an older version (3.9 or earlier), so it raises:

TypeError: unsupported operand type(s) for |: '_GenericAlias' and 'NoneType'


---

2 quick ways to fix it

A. Keep your current Python and switch to Optional[...]

Replace every T | None with Optional[T] and import Optional from typing.

import os
import shutil
from pathlib import Path
from typing import List, Optional, Sequence, Union   # â† add Optional

def find_latest_file_and_copy(
    source_dirs: Union[str, Path, Sequence[Union[str, Path]]],
    destination_dir: Union[str, Path],
    keywords: Optional[List[str]] = None,            # â† use Optional
    case_sensitive: bool = False,
) -> Path:
    # ---------- normalise inputs ----------------------------
    if isinstance(source_dirs, (str, Path)):
        source_dirs = [source_dirs]

    dest = Path(destination_dir)
    dest.mkdir(parents=True, exist_ok=True)

    # ---------- keyword prep --------------------------------
    kws = []
    if keywords:
        kws = keywords if case_sensitive else [k.lower() for k in keywords]

    # ---------- find newest matching file -------------------
    latest_file = None
    latest_mtime = 0

    for src in source_dirs:
        for root, _, files in os.walk(src):
            for file in files:
                # keyword filter
                name = file if case_sensitive else file.lower()
                if kws and not any(kw in name for kw in kws):
                    continue

                fp = os.path.join(root, file)
                try:
                    mtime = os.path.getmtime(fp)
                except OSError:
                    continue

                if mtime > latest_mtime:
                    latest_mtime = mtime
                    latest_file  = fp

    if latest_file is None:
        raise FileNotFoundError("No file matched the given keywords.")

    # ---------- copy & return -------------------------------
    dest_path = dest / Path(latest_file).name
    shutil.copy2(latest_file, dest_path)
    print(f"Copied '{latest_file}' â†’ '{dest_path}'")
    return dest_path

> Thatâ€™s the only changeâ€”everything else keeps working exactly as before.




---

B. Upgrade your environment to Python 3.10+

If youâ€™d like the modern | syntax (and other 3.10 perks), install / switch to a 3.10 or newer interpreter:

# Example for conda
conda create -n py310 python=3.10
conda activate py310
pip install notebook  # or jupyterlab / VS Code etc.

Then your original code compiles without edits.


---

TL;DR

Stay on 3.8/3.9 â†’ change List[str] | None to Optional[List[str]].

Move to 3.10+ â†’ keep the pipe syntax.


Pick whichever suits your setup and youâ€™ll be good to go. Happy coding!

