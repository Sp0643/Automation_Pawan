Below is a beginner-friendly, “build-it-as-you-go” walkthrough followed by the complete function.
Feel free to run each numbered cell in an interactive Python session (Jupyter, VS Code, or IDLE) to see what’s happening at every step.


---

1. Imports you’ll need

# 1️⃣  Core libraries
from pathlib import Path      # modern, object-oriented file paths
import shutil                 # for copying files
from typing import List       # for type hints (optional)


---

2. Gather every file under the source folder (recursively)

# 2️⃣  Replace this with your own folder
SRC_ROOT = Path(r"C:\path\to\source")

all_files = [p for p in SRC_ROOT.rglob("*") if p.is_file()]
print(f"Found {len(all_files)} files")

Path.rglob("*") walks all sub-directories automatically.
You should now see how many files were detected.


---

3. Keep only files whose names contain one (or more) keywords

# 3️⃣  Define ANY keywords you want to match in the filename
keywords = ["sales", "report", "2025"]

def has_keyword(path: Path, kw_list: List[str], case_sensitive=False) -> bool:
    name = path.name if case_sensitive else path.name.lower()
    kws  = kw_list         if case_sensitive else [k.lower() for k in kw_list]
    return any(kw in name for kw in kws)

filtered = [f for f in all_files if has_keyword(f, keywords)]
print(f"Matched {len(filtered)} files with keywords {keywords}")


---

4. Pick the most recently modified file from the filtered list

# 4️⃣  Use the file’s “last-modified” timestamp
latest_file = max(filtered, key=lambda p: p.stat().st_mtime, default=None)

if latest_file is None:
    raise FileNotFoundError("No files matched the given keywords.")
print(f"Newest file is: {latest_file}")


---

5. Copy it to the destination folder

# 5️⃣  Destination directory (will be created if missing)
DST_DIR = Path(r"C:\path\to\destination")
DST_DIR.mkdir(parents=True, exist_ok=True)

# Preserve original filename and metadata
copied_to = DST_DIR / latest_file.name
shutil.copy2(latest_file, copied_to)

print(f"Copied → {copied_to}")


---

6. (Optional) Keep only the N most recent files in the destination

def prune_destination(dest: Path, keep_last: int = 3):
    files = sorted(
        [p for p in dest.iterdir() if p.is_file()],
        key=lambda p: p.stat().st_mtime,
        reverse=True,
    )
    for old in files[keep_last:]:
        old.unlink()          # permanently delete
        print(f"Deleted old backup: {old}")

# Uncomment if you want this behaviour
# prune_destination(DST_DIR, keep_last=3)


---

7. Full function

Here’s the same logic wrapped in one tidy, reusable function:

from pathlib import Path
import shutil
from typing import List, Optional

def copy_latest_file(
    src_root: str | Path,
    dst_dir: str | Path,
    keywords: List[str],
    case_sensitive: bool = False,
    keep_last: Optional[int] = None,
) -> Path:
    """
    Find the newest file under `src_root` whose *filename* contains ANY of
    the given `keywords`, copy it into `dst_dir`, and (optionally) keep only
    the last `keep_last` files in that destination.

    Returns the Path of the copied file.
    """
    src_root = Path(src_root)
    dst_dir  = Path(dst_dir)
    dst_dir.mkdir(parents=True, exist_ok=True)

    # 1. Find all matching files
    matches = [
        p for p in src_root.rglob("*") if p.is_file()
        and (
            (set(k if case_sensitive else k.lower() for k in keywords)
             & {p.name}  # dummy to force evaluation
             or any((k if case_sensitive else k.lower()) in
                    (p.name if case_sensitive else p.name.lower())
                    for k in keywords))
        )
    ]
    if not matches:
        raise FileNotFoundError("No file found with the specified keywords.")

    # 2. Choose the newest
    latest = max(matches, key=lambda p: p.stat().st_mtime)

    # 3. Copy it
    dest_path = dst_dir / latest.name
    shutil.copy2(latest, dest_path)

    # 4. Optionally prune old copies
    if keep_last is not None:
        files = sorted(
            [f for f in dst_dir.iterdir() if f.is_file()],
            key=lambda p: p.stat().st_mtime,
            reverse=True,
        )
        for old in files[keep_last:]:
            old.unlink()

    return dest_path

Usage

dest = copy_latest_file(
    src_root=r"C:\Data",
    dst_dir=r"C:\Backup\Daily",
    keywords=["sales", ".xlsx"],
    keep_last=3,            # omit or set to None if you don’t want pruning
)
print("Latest file copied to:", dest)


---

Why this design is beginner-friendly

1. Pathlib everywhere – no back-slash headaches, clear methods (rglob, stem, suffix, etc.).


2. Step-by-step build – run each section, inspect variables, gain confidence.


3. Plain English docstring & comments – quickly recall what each piece does.


4. Optional clean-up – copy-paste the function even if you don’t need the pruning part.



You can now adapt the keyword list, source/destination folders, or the retention rule with a single line change. Happy coding!

Absolutely! Let's start from the very basics, so you understand what a function is, how it works, and how to build up gradually to a more complex one.


---

🔹 What is a Python Function?

A function is like a recipe. You give it some ingredients (called inputs or arguments), and it gives you a result (called output or return value).


---

✅ Step 1: Your First Function (Simple Addition)

def add_numbers(a, b):
    result = a + b
    return result

Explanation:

def means you're defining a function.

add_numbers is the name of the function.

a, b are inputs.

a + b adds the numbers.

return result gives the output.


Try it:

print(add_numbers(2, 3))  # Output: 5


---

✅ Step 2: Add a Message (More Friendly Output)

def greet_user(name):
    print("Hello, " + name + "!")

greet_user("Sohan")  # Output: Hello, Sohan!


---

✅ Step 3: A Function with Decision Making (if-else)

def check_even_or_odd(number):
    if number % 2 == 0:
        return "Even"
    else:
        return "Odd"

print(check_even_or_odd(4))  # Output: Even
print(check_even_or_odd(7))  # Output: Odd


---

✅ Step 4: A Slightly Complex One – Average of List

def calculate_average(numbers):
    total = sum(numbers)
    count = len(numbers)
    average = total / count
    return average

my_list = [10, 20, 30, 40]
print(calculate_average(my_list))  # Output: 25.0


---

✅ Step 5: Final: Build a Custom Function Together

Let’s say you want to:

Take a list of numbers.

Remove any negative numbers.

Square the remaining numbers.

Return the result.


def process_numbers(numbers):
    clean_numbers = []
    for num in numbers:
        if num >= 0:
            clean_numbers.append(num ** 2)
    return clean_numbers

sample = [1, -2, 3, -4, 5]
print(process_numbers(sample))  # Output: [1, 9, 25]


---

Would you like to now:

1. Try writing a function yourself and I’ll guide you?


2. Move to more complex logic like working with files, charts, or APIs?


3. Build something fun like a number guessing game or calculator?



Let me know your goal!




Below is a mini-lesson you can run step-by-step.
Each step adds one small idea; run it, inspect the output, and move on.
At the end you’ll see the same pieces put together as one tidy function.


---

0.  Imports we’ll need

from pathlib import Path        # modern, OS-independent path handling
import shutil                   # for copying files
import time                     # only for pretty-printing timestamps in this demo


---

1.  Point to your folders

# 👉 Change these to match your machine
SRC_DIR = Path(r"C:\Data\Reports")     # search starts here (all sub-folders included)
DST_DIR = Path(r"C:\Data\Latest")      # where the newest file will be copied

# Make sure the destination exists
DST_DIR.mkdir(parents=True, exist_ok=True)

Why Path instead of plain strings?
Path objects work the same on Windows, macOS, and Linux and give you handy methods like .rglob().


---

2.  Find all files under SRC_DIR

all_files = [f for f in SRC_DIR.rglob("*") if f.is_file()]
print(f"Found {len(all_files)} files")

What just happened?

.rglob("*") walks every sub-folder.

f.is_file() keeps regular files and skips directories.



---

3.  Filter by a keyword (or several)

KEYWORDS = ["sales", "2025"]   # match files whose *names* contain BOTH words

def name_has_keywords(path, keywords):
    name_lower = path.name.lower()
    return all(k.lower() in name_lower for k in keywords)

matching_files = [f for f in all_files if name_has_keywords(f, KEYWORDS)]
print(f"{len(matching_files)} files match {KEYWORDS}")

(Change the words or add more to get the filter you need.)


---

4.  Pick the most recently modified one

latest = max(matching_files, key=lambda f: f.stat().st_mtime)
print("Latest file:", latest.name)
print("Modified:", time.ctime(latest.stat().st_mtime))

.stat().st_mtime returns the epoch time (seconds since 1970-01-01).
max(..., key=...) grabs the path whose timestamp is greatest.


---

5.  Copy it to the destination

destination_path = DST_DIR / latest.name          # keep the same file name
shutil.copy2(latest, destination_path)            # copy2 preserves timestamps
print("Copied to:", destination_path)

That’s the whole workflow in bite-size pieces.
Once each cell behaves as expected, you’re ready for the one-shot function 👇.


---

6.  The full beginner-friendly function

from pathlib import Path
import shutil

def copy_latest_file(src_dir, dst_dir, keywords):
    """
    Search `src_dir` (incl. sub-folders) for the newest file whose *name*
    contains *all* `keywords` (case-insensitive).  Copy it into `dst_dir`
    and return the destination Path.

    Example
    -------
    copy_latest_file(
        r"C:\Data\Reports",                # source tree
        r"C:\Data\Latest",                 # destination folder
        keywords=["sales", "2025"]         # words that must appear in the file name
    )
    """
    src_dir = Path(src_dir)
    dst_dir = Path(dst_dir)
    dst_dir.mkdir(parents=True, exist_ok=True)

    # Collect candidate files
    def match(p):
        name = p.name.lower()
        return all(k.lower() in name for k in keywords)

    matches = [p for p in src_dir.rglob("*") if p.is_file() and match(p)]
    if not matches:
        raise FileNotFoundError(f"No files containing {keywords} found under {src_dir}")

    # Latest by modification time
    latest = max(matches, key=lambda p: p.stat().st_mtime)

    # Copy it
    target = dst_dir / latest.name
    shutil.copy2(latest, target)   # use copy2 to preserve metadata
    return target

How to use it

new_file = copy_latest_file(
    src_dir=r"C:\Data\Reports",
    dst_dir=r"C:\Data\Latest",
    keywords=["sales", "2025"]
)
print("✅ Copied:", new_file)


---

What if I need to keep only the last N files in the destination?

Add two lines at the end of the function:

# --- optional clean-up: keep only N most recent files in dst_dir ---
    N = 3
    existing = sorted(dst_dir.glob("*"), key=lambda p: p.stat().st_mtime, reverse=True)
    for old in existing[N:]:
        old.unlink()                      # delete anything older than the N freshest


---

Why these libraries?

Library	Why we picked it

pathlib	Clear, cross-platform paths
shutil	Easy, reliable file copy
time	Only for human-readable timestamp printing in demos


Everything is in the Python standard library—no extra installs required.
Happy automating!



Here’s a drop-in replacement for your current find_latest_file_and_copy that adds keyword filtering while staying almost identical to the code you’re already running.

import os
import shutil
from pathlib import Path
from typing import List, Union, Sequence

def find_latest_file_and_copy(
    source_dirs: Union[str, Path, Sequence[Union[str, Path]]],
    destination_dir: Union[str, Path],
    keywords: List[str] | None = None,
    case_sensitive: bool = False,
) -> Path:
    """
    Look through one *or* many source folders (recursively), find the most
    recently-modified file whose **name** contains ANY of `keywords`, and copy
    it to `destination_dir`.

    Parameters
    ----------
    source_dirs      : str | Path | list/tuple
        A single directory *or* an iterable of directories to search.
    destination_dir  : str | Path
        Where the newest matching file will be copied.
    keywords         : list[str] | None
        Text snippets to look for in the filename. If None or empty, every
        file counts.
    case_sensitive   : bool
        Match keywords with or without case-sensitivity.

    Returns
    -------
    pathlib.Path
        The full path of the file that was copied.
    """
    # ---- normalise inputs ---------------------------------------------------
    if isinstance(source_dirs, (str, Path)):
        source_dirs = [source_dirs]

    dest = Path(destination_dir)
    dest.mkdir(parents=True, exist_ok=True)

    # ---- keyword pre-processing --------------------------------------------
    if keywords:
        kws = keywords if case_sensitive else [k.lower() for k in keywords]
    else:
        kws = []   # treat as "no filtering"

    # ---- search for newest matching file ------------------------------------
    latest_file      = None
    latest_file_mtime = 0

    for src in source_dirs:
        for root, _, files in os.walk(src):
            for file in files:
                # ① keyword filter
                name_to_check = file if case_sensitive else file.lower()
                if kws and not any(kw in name_to_check for kw in kws):
                    continue  # skip non-matches

                # ② compare modification time
                file_path = os.path.join(root, file)
                try:
                    mtime = os.path.getmtime(file_path)
                except OSError:
                    continue  # ignore unreadable files

                if mtime > latest_file_mtime:
                    latest_file_mtime  = mtime
                    latest_file        = file_path

    # ---- copy result (if found) ---------------------------------------------
    if latest_file is None:
        raise FileNotFoundError("No file matched the given keywords.")

    dest_path = dest / Path(latest_file).name
    shutil.copy2(latest_file, dest_path)  # copy2 keeps timestamps/metadata
    print(f"Copied '{latest_file}'  →  '{dest_path}'")

    return dest_path


---

How to call it

# One directory
find_latest_file_and_copy(
    source_dirs=r"\\ent.wfb.bank.corp\WHLSDFS\Shared\Agency Services\Daily Reports",
    destination_dir=r"C:\Backups\Daily",
    keywords=["wip", "report"],   # match ANY of these
    case_sensitive=False,         # ignore case (default)
)

# Many directories
sources = [
    r"\\...Financial Cash Controls\...\2025",
    r"\\...Agency Servicing\VIP\ARCOE Recons\ATI 1007201",
    r"\\...MCCY Recon\2025",
]
find_latest_file_and_copy(
    source_dirs=sources,
    destination_dir=r"C:\Backups\Daily",
    keywords=[".xlsx", "wip"],     # e.g. only Excel WIP files
)

What changed compared to your original snippet?

Feature	Old version	New version

Keyword filter	✘	✔ keywords argument, case-toggle
Multiple source roots	✘ (single)	✔ source_dirs accepts list / tuple
Pathlib for destination	partial	full use for mkdir & return value
Type hints / docstring	minimal	expanded, beginner-friendly


Copy the function into your script/notebook, adjust the call as shown, and you’re done. Let me know if you’d like any extra tweaks (e.g. keeping only the last N backups in the destination).

What went wrong?
The | (pipe) syntax for “A or B” type hints only works in Python 3.10+.
Your notebook/kernel is on an older version (3.9 or earlier), so it raises:

TypeError: unsupported operand type(s) for |: '_GenericAlias' and 'NoneType'


---

2 quick ways to fix it

A. Keep your current Python and switch to Optional[...]

Replace every T | None with Optional[T] and import Optional from typing.

import os
import shutil
from pathlib import Path
from typing import List, Optional, Sequence, Union   # ← add Optional

def find_latest_file_and_copy(
    source_dirs: Union[str, Path, Sequence[Union[str, Path]]],
    destination_dir: Union[str, Path],
    keywords: Optional[List[str]] = None,            # ← use Optional
    case_sensitive: bool = False,
) -> Path:
    # ---------- normalise inputs ----------------------------
    if isinstance(source_dirs, (str, Path)):
        source_dirs = [source_dirs]

    dest = Path(destination_dir)
    dest.mkdir(parents=True, exist_ok=True)

    # ---------- keyword prep --------------------------------
    kws = []
    if keywords:
        kws = keywords if case_sensitive else [k.lower() for k in keywords]

    # ---------- find newest matching file -------------------
    latest_file = None
    latest_mtime = 0

    for src in source_dirs:
        for root, _, files in os.walk(src):
            for file in files:
                # keyword filter
                name = file if case_sensitive else file.lower()
                if kws and not any(kw in name for kw in kws):
                    continue

                fp = os.path.join(root, file)
                try:
                    mtime = os.path.getmtime(fp)
                except OSError:
                    continue

                if mtime > latest_mtime:
                    latest_mtime = mtime
                    latest_file  = fp

    if latest_file is None:
        raise FileNotFoundError("No file matched the given keywords.")

    # ---------- copy & return -------------------------------
    dest_path = dest / Path(latest_file).name
    shutil.copy2(latest_file, dest_path)
    print(f"Copied '{latest_file}' → '{dest_path}'")
    return dest_path

> That’s the only change—everything else keeps working exactly as before.




---

B. Upgrade your environment to Python 3.10+

If you’d like the modern | syntax (and other 3.10 perks), install / switch to a 3.10 or newer interpreter:

# Example for conda
conda create -n py310 python=3.10
conda activate py310
pip install notebook  # or jupyterlab / VS Code etc.

Then your original code compiles without edits.


---

TL;DR

Stay on 3.8/3.9 → change List[str] | None to Optional[List[str]].

Move to 3.10+ → keep the pipe syntax.


Pick whichever suits your setup and you’ll be good to go. Happy coding!




Below is a ready-to-use script that folds in every improvement we discussed:

✅ pathlib throughout – cleaner paths, no back-slash headaches

✅ Keyword filter – only consider files whose names contain any of the given words

✅ Optional renaming – avoids accidental overwrites when two sources share a filename

✅ Keep only the last N backups in the destination folder

✅ Basic logging – prints to screen and writes a timestamped log file


> Run it as-is (edit the config block at the bottom), or import the two functions into another project.



#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Copy the *latest* file from one or more source folders into a single
destination folder with optional keyword filtering, automated renaming
(to avoid overwrites), retention housekeeping, and simple logging.

Compatible with Python 3.8+
"""

from __future__ import annotations
import logging
from datetime import datetime
from pathlib import Path
from shutil   import copy2
from typing   import Iterable, List, Optional, Sequence, Union

# ──────────────────────────────────────────────────────────────────────
# 1.  Logger helper
# ──────────────────────────────────────────────────────────────────────
def setup_logger(log_dir: Path | str) -> logging.Logger:
    """Create (or reuse) a logger that writes to <log_dir>/copy_latest.log"""
    log_dir = Path(log_dir)
    log_dir.mkdir(parents=True, exist_ok=True)

    logger = logging.getLogger("copy_latest")
    if logger.handlers:          # already configured
        return logger

    logger.setLevel(logging.INFO)
    fmt = logging.Formatter("[%(asctime)s] %(levelname)s: %(message)s",
                            datefmt="%Y-%m-%d %H:%M:%S")

    # file handler
    fh = logging.FileHandler(log_dir / "copy_latest.log", encoding="utf-8")
    fh.setFormatter(fmt)
    logger.addHandler(fh)

    # console handler
    ch = logging.StreamHandler()
    ch.setFormatter(fmt)
    logger.addHandler(ch)

    return logger


# ──────────────────────────────────────────────────────────────────────
# 2.  Core utility: newest file inside *one* folder tree
# ──────────────────────────────────────────────────────────────────────
def newest_file(
    root: Path,
    keywords: Optional[List[str]] = None,
    case_sensitive: bool = False,
) -> Optional[Path]:
    """
    Walk `root` recursively and return the Path to the most recently
    modified file whose name contains ANY of the `keywords`.

    If `keywords` is None or empty ⇒ every file counts.
    """
    if keywords:
        kws = keywords if case_sensitive else [k.lower() for k in keywords]
    else:
        kws = []

    latest: Optional[Path] = None
    latest_mtime = 0.0

    for file in root.rglob("*"):
        if not file.is_file():
            continue

        name = file.name if case_sensitive else file.name.lower()
        if kws and not any(kw in name for kw in kws):
            continue

        try:
            mtime = file.stat().st_mtime
        except OSError:
            continue

        if mtime > latest_mtime:
            latest_mtime = mtime
            latest = file

    return latest


# ──────────────────────────────────────────────────────────────────────
# 3.  Main routine – can handle MANY source roots
# ──────────────────────────────────────────────────────────────────────
def copy_latest_files(
    source_dirs: Union[Path, str, Sequence[Union[Path, str]]],
    destination_dir: Union[Path, str],
    *,
    keywords: Optional[List[str]] = None,
    case_sensitive: bool = False,
    keep_last: Optional[int] = 5,
    rename_if_exists: bool = True,
    logger: Optional[logging.Logger] = None,
) -> None:
    """
    For each folder in `source_dirs`, find its newest matching file and
    copy it into `destination_dir`.

    Parameters
    ----------
    source_dirs        : single path *or* sequence of paths
    destination_dir    : where copies go (created if missing)
    keywords           : list of words/substrings to filter filenames
    keep_last          : keep only the `keep_last` most recent files
                         in the destination folder (None = keep all)
    rename_if_exists   : add a timestamp suffix if the filename already
                         exists in destination to avoid overwrite
    """
    if isinstance(source_dirs, (str, Path)):
        source_dirs = [source_dirs]

    dest = Path(destination_dir)
    dest.mkdir(parents=True, exist_ok=True)

    logger = logger or setup_logger(dest)

    for src in source_dirs:
        src_path = Path(src)
        if not src_path.exists():
            logger.warning(f"Source '{src_path}' does not exist – skipped.")
            continue

        latest = newest_file(src_path, keywords, case_sensitive)
        if latest is None:
            logger.info(f"No matching files in '{src_path}'.")
            continue

        # ── construct destination filename ────────────────────────────
        target = dest / latest.name
        if target.exists() and rename_if_exists:
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            target = dest / f"{latest.stem}_{ts}{latest.suffix}"

        try:
            copy2(latest, target)
            logger.info(f"Copied '{latest}'  →  '{target}'")
        except Exception as e:
            logger.error(f"Failed to copy '{latest}': {e}")

    # ── retention housekeeping ───────────────────────────────────────
    if keep_last is not None:
        files = sorted(
            [f for f in dest.iterdir() if f.is_file()],
            key=lambda p: p.stat().st_mtime,
            reverse=True,
        )
        for old in files[keep_last:]:
            try:
                old.unlink()
                logger.info(f"Pruned old backup '{old.name}'")
            except Exception as e:
                logger.warning(f"Could not delete '{old}': {e}")


# ──────────────────────────────────────────────────────────────────────
# 4.  Example “config block” – edit & run
# ──────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    # --- 4a. where to search -------------------------------------------------
    SOURCES: Iterable[Path | str] = [
        r"\\ent.wfb.bank.corp\WHLSDFS\Shared\Agency Services\Financial Cash Controls\1_Daily Reports\Daily WIP Report\2025",
        r"\\ent.wfb.bank.corp\WHLSDFS\Shared\Agency Services\Agency Servicing\WIP\ARCOE Recons\MT 1007201",
        r"\\ent.wfb.bank.corp\WHLSDFS\Shared\Agency Services\Agency Servicing\WIP\ARCOE Recons\MCCY Recon\2025",
        # add more paths as needed ...
    ]

    # --- 4b. destination “drop zone” ----------------------------------------
    DESTINATION = (
        r"\\ent.wfb.bank.corp\WHLSDFS\Shared\Agency Services\Financial Cash Controls"
        r"\FCC_Exception_Recon\DailyWIPBackups"
    )

    # --- 4c. filtering & housekeeping ---------------------------------------
    KEYWORDS     = ["wip", ".xlsx"]     # Any file whose *name* contains one
    KEEP_LAST    = 3                    # keep only newest 3 copies
    CASE_SENSE   = False                # ignore case in matching

    # --- 4d. run! ------------------------------------------------------------
    copy_latest_files(
        source_dirs   = SOURCES,
        destination_dir = DESTINATION,
        keywords        = KEYWORDS,
        case_sensitive  = CASE_SENSE,
        keep_last       = KEEP_LAST,
        rename_if_exists= True,
    )


---

How it works, in a nutshell

1. newest_file() walks a single folder tree with Path.rglob("*"), filters on keywords, and returns the most recently modified file.


2. copy_latest_files()

loops over as many source roots as you supply

copies each folder’s newest file into one common destination

if two files share a name, it appends a timestamp to avoid overwriting

finally, it deletes older backups so only the last keep_last remain



3. Logging goes to both the terminal and copy_latest.log inside the destination folder, giving you an audit trail.



Just tweak the “config block” at the bottom (source paths, keywords, retention count), save, and run the script from any environment that has network-share access.

Below you’ll find two parts:

1. Plain-English walkthrough of what each section of the script does so you understand the flow.


2. Same code rewritten with inline comments and a docstring so future-you (or a teammate) can read it quickly.




---

1. What the script does, step by step

Step	Action	Why it matters

1	Define find_latest_file_and_copy(source_dir, destination_dir)	Encapsulates the “search → pick newest → copy” workflow so you can reuse it on many folders.
2	Initialise latest_file = None and latest_file_mtime = 0	Keeps track of the newest file seen so far and its “modified‐time” (epoch seconds).
3	os.walk(source_dir)	Recursively iterates through all sub-folders and files under the given root.
4	For every file, build its full path with os.path.join(root, file)	Needed because os.walk returns only the filename, not the folder.
5	Get each file’s “last modified” timestamp with os.path.getmtime	Used to decide which file is the most recent.
6	If the timestamp is newer than latest_file_mtime, store this path + time	Running maximum pattern lets you finish with the single most recent file.
7	After the loop ends, check if latest_file:	Handles the case where the folder tree was empty.
8	shutil.copy2(latest_file, destination_dir)	Copies and preserves metadata (timestamps, permissions).
9	Wrap I/O calls in try … except blocks	Prevents the whole script from crashing if one path is unreadable or the copy fails.
10	In the “main” block: build four source paths, one destination path, ensure the destination directory exists (os.makedirs(..., exist_ok=True)), then call the function for each source.	



---

2. Script with detailed comments

#!/usr/bin/env python3
"""
Copy the most recently-modified file from one or more source directories
(recursive search) into a single destination directory.

© 2025  (feel free to add licence / author info here)
"""
from __future__ import annotations

import os
import shutil
from typing import Optional


def find_latest_file_and_copy(source_dir: str, destination_dir: str) -> None:
    """
    Locate the *newest* file anywhere under `source_dir` and copy it to
    `destination_dir`, preserving the file’s metadata.

    Parameters
    ----------
    source_dir : str
        Root folder to search (walks through all sub-folders).
    destination_dir : str
        Folder where the newest file will be copied.

    Notes
    -----
    • Uses `shutil.copy2` (rather than `copy`) so timestamps/permissions survive.  
    • Prints progress instead of raising, so one bad file won’t abort the run.
    """
    latest_file: Optional[str] = None           # full path of newest file seen
    latest_file_mtime: float = 0.0              # its modification time (epoch)

    # --- Walk through *every* sub-directory and file ------------------------
    for root, _dirs, files in os.walk(source_dir):
        for file in files:
            file_path = os.path.join(root, file)

            try:
                # Last-modified timestamp as seconds since 1970-01-01
                mtime = os.path.getmtime(file_path)
            except OSError as err:
                # e.g. permission denied, path vanished, etc.
                print(f"[WARN] Cannot stat {file_path!r}: {err}")
                continue

            # Keep track of the freshest file so far
            if mtime > latest_file_mtime:
                latest_file_mtime = mtime
                latest_file = file_path

    # ------------------------------------------------------------------------
    if latest_file is None:
        print(f"[INFO] No files found under {source_dir!r}")
        return

    print(f"[INFO] Newest file in {source_dir!r}: {latest_file!r}")

    try:
        shutil.copy2(latest_file, destination_dir)
        print(f"[OK]   Copied to → {destination_dir}")
    except Exception as err:  # broad, but we log & carry on
        print(f"[ERR]  Failed to copy {latest_file!r}: {err}")


# --------------------------------------------------------------------------- #
# Example usage                                                               #
# --------------------------------------------------------------------------- #
if __name__ == "__main__":
    # --- Define source locations (raw strings avoid back-slash escapes) -----
    source_directory1 = r"\\net.wfb.bank.corp\WHLSDFS\Shared\Agency Services\Financial Cash Controls\J - Daily Reports\Daily WIP Report\2025"
    source_directory2 = r"\\net.wfb.bank.corp\WHLSDFS\Shared\Agency Servicing\WIP\AROE Recons\MT_1007201"
    source_directory3 = r"\\net.wfb.bank.corp\WHLSDFS\Shared\Agency Servicing\WIP\AROE Recons\MCCY Recon\2025"
    source_directory4 = r"\\net.wfb.bank.corp\WHLSDFS\Shared\Agency Servicing\WIP\AROE Recons\WT_DDA_ACH_SWEEP"

    # Folder that will receive each “latest” file
    destination_directory = (
        r"\\net.wfb.bank.corp\WHLSDFS\Shared\Agency Services\Financial Cash Controls\FCC_Exception_Recon"
    )

    # Make sure the destination exists (won’t error if it already does)
    os.makedirs(destination_directory, exist_ok=True)

    # Iterate over each source root and perform the copy
    for src in (source_directory1, source_directory2, source_directory3, source_directory4):
        find_latest_file_and_copy(src, destination_directory)


---

Key take-aways

os.walk gives you a depth-first traversal, so you don’t need extra logic for sub-folders.

shutil.copy2 is a handy one-liner when you want to keep original timestamps.

Wrapping file I/O in try/except keeps long batch jobs resilient—one bad path won’t halt the script.


Feel free to adjust log messages, add a keyword filter, or convert the prints to logging calls if you need more control over verbosity.



Below is the drop-in replacement for the original function.
Only six tiny edits were made, all marked with # <-- NEW so you can spot them quickly.

def find_latest_file_and_copy(
    source_dir: str,
    destination_dir: str,
    keyword: str | None = None          # <-- NEW (optional filter)
) -> None:
    """
    Locate the newest file under `source_dir` (recursive) and copy it to
    `destination_dir`.  
    If *keyword* is supplied, only files whose **name contains that text**
    (case-insensitive) are considered when choosing “newest”.
    """
    latest_file: Optional[str] = None
    latest_file_mtime: float = 0.0

    for root, _dirs, files in os.walk(source_dir):
        for file in files:

            # Skip files that don't match the keyword, if one was provided
            if keyword and keyword.lower() not in file.lower():   # <-- NEW
                continue                                          # <-- NEW

            file_path = os.path.join(root, file)

            try:
                mtime = os.path.getmtime(file_path)
            except OSError as err:
                print(f"[WARN] Cannot stat {file_path!r}: {err}")
                continue

            if mtime > latest_file_mtime:
                latest_file_mtime = mtime
                latest_file = file_path

    if latest_file is None:
        msg = f"No files found under {source_dir!r}"
        if keyword:                                              # <-- NEW
            msg += f" matching keyword {keyword!r}"              # <-- NEW
        print(f"[INFO] {msg}")
        return

    print(f"[INFO] Newest file in {source_dir!r}: {latest_file!r}")

    try:
        shutil.copy2(latest_file, destination_dir)
        print(f"[OK]   Copied to → {destination_dir}")
    except Exception as err:
        print(f"[ERR]  Failed to copy {latest_file!r}: {err}")

How to call it

# Copy the newest “_Recon” file from each source directory
for src in (source_directory1, source_directory2, source_directory3, source_directory4):
    find_latest_file_and_copy(src, destination_directory, keyword="_Recon")

Omit the keyword argument (or pass None) to get the original, “no-filter” behaviour.

Matching is case-insensitive and checks the filename only (not folder segments).



