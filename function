Below is a beginner-friendly, â€œbuild-it-as-you-goâ€ walkthrough followed by the complete function.
Feel free to run each numbered cell in an interactive Python session (Jupyter, VS Code, or IDLE) to see whatâ€™s happening at every step.


---

1. Imports youâ€™ll need

# 1ï¸âƒ£  Core libraries
from pathlib import Path      # modern, object-oriented file paths
import shutil                 # for copying files
from typing import List       # for type hints (optional)


---

2. Gather every file under the source folder (recursively)

# 2ï¸âƒ£  Replace this with your own folder
SRC_ROOT = Path(r"C:\path\to\source")

all_files = [p for p in SRC_ROOT.rglob("*") if p.is_file()]
print(f"Found {len(all_files)} files")

Path.rglob("*") walks all sub-directories automatically.
You should now see how many files were detected.


---

3. Keep only files whose names contain one (or more) keywords

# 3ï¸âƒ£  Define ANY keywords you want to match in the filename
keywords = ["sales", "report", "2025"]

def has_keyword(path: Path, kw_list: List[str], case_sensitive=False) -> bool:
    name = path.name if case_sensitive else path.name.lower()
    kws  = kw_list         if case_sensitive else [k.lower() for k in kw_list]
    return any(kw in name for kw in kws)

filtered = [f for f in all_files if has_keyword(f, keywords)]
print(f"Matched {len(filtered)} files with keywords {keywords}")


---

4. Pick the most recently modified file from the filtered list

# 4ï¸âƒ£  Use the fileâ€™s â€œlast-modifiedâ€ timestamp
latest_file = max(filtered, key=lambda p: p.stat().st_mtime, default=None)

if latest_file is None:
    raise FileNotFoundError("No files matched the given keywords.")
print(f"Newest file is: {latest_file}")


---

5. Copy it to the destination folder

# 5ï¸âƒ£  Destination directory (will be created if missing)
DST_DIR = Path(r"C:\path\to\destination")
DST_DIR.mkdir(parents=True, exist_ok=True)

# Preserve original filename and metadata
copied_to = DST_DIR / latest_file.name
shutil.copy2(latest_file, copied_to)

print(f"Copied â†’ {copied_to}")


---

6. (Optional) Keep only the N most recent files in the destination

def prune_destination(dest: Path, keep_last: int = 3):
    files = sorted(
        [p for p in dest.iterdir() if p.is_file()],
        key=lambda p: p.stat().st_mtime,
        reverse=True,
    )
    for old in files[keep_last:]:
        old.unlink()          # permanently delete
        print(f"Deleted old backup: {old}")

# Uncomment if you want this behaviour
# prune_destination(DST_DIR, keep_last=3)


---

7. Full function

Hereâ€™s the same logic wrapped in one tidy, reusable function:

from pathlib import Path
import shutil
from typing import List, Optional

def copy_latest_file(
    src_root: str | Path,
    dst_dir: str | Path,
    keywords: List[str],
    case_sensitive: bool = False,
    keep_last: Optional[int] = None,
) -> Path:
    """
    Find the newest file under `src_root` whose *filename* contains ANY of
    the given `keywords`, copy it into `dst_dir`, and (optionally) keep only
    the last `keep_last` files in that destination.

    Returns the Path of the copied file.
    """
    src_root = Path(src_root)
    dst_dir  = Path(dst_dir)
    dst_dir.mkdir(parents=True, exist_ok=True)

    # 1. Find all matching files
    matches = [
        p for p in src_root.rglob("*") if p.is_file()
        and (
            (set(k if case_sensitive else k.lower() for k in keywords)
             & {p.name}  # dummy to force evaluation
             or any((k if case_sensitive else k.lower()) in
                    (p.name if case_sensitive else p.name.lower())
                    for k in keywords))
        )
    ]
    if not matches:
        raise FileNotFoundError("No file found with the specified keywords.")

    # 2. Choose the newest
    latest = max(matches, key=lambda p: p.stat().st_mtime)

    # 3. Copy it
    dest_path = dst_dir / latest.name
    shutil.copy2(latest, dest_path)

    # 4. Optionally prune old copies
    if keep_last is not None:
        files = sorted(
            [f for f in dst_dir.iterdir() if f.is_file()],
            key=lambda p: p.stat().st_mtime,
            reverse=True,
        )
        for old in files[keep_last:]:
            old.unlink()

    return dest_path

Usage

dest = copy_latest_file(
    src_root=r"C:\Data",
    dst_dir=r"C:\Backup\Daily",
    keywords=["sales", ".xlsx"],
    keep_last=3,            # omit or set to None if you donâ€™t want pruning
)
print("Latest file copied to:", dest)


---

Why this design is beginner-friendly

1. Pathlib everywhere â€“ no back-slash headaches, clear methods (rglob, stem, suffix, etc.).


2. Step-by-step build â€“ run each section, inspect variables, gain confidence.


3. Plain English docstring & comments â€“ quickly recall what each piece does.


4. Optional clean-up â€“ copy-paste the function even if you donâ€™t need the pruning part.



You can now adapt the keyword list, source/destination folders, or the retention rule with a single line change. Happy coding!

Absolutely! Let's start from the very basics, so you understand what a function is, how it works, and how to build up gradually to a more complex one.


---

ðŸ”¹ What is a Python Function?

A function is like a recipe. You give it some ingredients (called inputs or arguments), and it gives you a result (called output or return value).


---

âœ… Step 1: Your First Function (Simple Addition)

def add_numbers(a, b):
    result = a + b
    return result

Explanation:

def means you're defining a function.

add_numbers is the name of the function.

a, b are inputs.

a + b adds the numbers.

return result gives the output.


Try it:

print(add_numbers(2, 3))  # Output: 5


---

âœ… Step 2: Add a Message (More Friendly Output)

def greet_user(name):
    print("Hello, " + name + "!")

greet_user("Sohan")  # Output: Hello, Sohan!


---

âœ… Step 3: A Function with Decision Making (if-else)

def check_even_or_odd(number):
    if number % 2 == 0:
        return "Even"
    else:
        return "Odd"

print(check_even_or_odd(4))  # Output: Even
print(check_even_or_odd(7))  # Output: Odd


---

âœ… Step 4: A Slightly Complex One â€“ Average of List

def calculate_average(numbers):
    total = sum(numbers)
    count = len(numbers)
    average = total / count
    return average

my_list = [10, 20, 30, 40]
print(calculate_average(my_list))  # Output: 25.0


---

âœ… Step 5: Final: Build a Custom Function Together

Letâ€™s say you want to:

Take a list of numbers.

Remove any negative numbers.

Square the remaining numbers.

Return the result.


def process_numbers(numbers):
    clean_numbers = []
    for num in numbers:
        if num >= 0:
            clean_numbers.append(num ** 2)
    return clean_numbers

sample = [1, -2, 3, -4, 5]
print(process_numbers(sample))  # Output: [1, 9, 25]


---

Would you like to now:

1. Try writing a function yourself and Iâ€™ll guide you?


2. Move to more complex logic like working with files, charts, or APIs?


3. Build something fun like a number guessing game or calculator?



Let me know your goal!




Below is a mini-lesson you can run step-by-step.
Each step adds one small idea; run it, inspect the output, and move on.
At the end youâ€™ll see the same pieces put together as one tidy function.


---

0.  Imports weâ€™ll need

from pathlib import Path        # modern, OS-independent path handling
import shutil                   # for copying files
import time                     # only for pretty-printing timestamps in this demo


---

1.  Point to your folders

# ðŸ‘‰ Change these to match your machine
SRC_DIR = Path(r"C:\Data\Reports")     # search starts here (all sub-folders included)
DST_DIR = Path(r"C:\Data\Latest")      # where the newest file will be copied

# Make sure the destination exists
DST_DIR.mkdir(parents=True, exist_ok=True)

Why Path instead of plain strings?
Path objects work the same on Windows, macOS, and Linux and give you handy methods like .rglob().


---

2.  Find all files under SRC_DIR

all_files = [f for f in SRC_DIR.rglob("*") if f.is_file()]
print(f"Found {len(all_files)} files")

What just happened?

.rglob("*") walks every sub-folder.

f.is_file() keeps regular files and skips directories.



---

3.  Filter by a keyword (or several)

KEYWORDS = ["sales", "2025"]   # match files whose *names* contain BOTH words

def name_has_keywords(path, keywords):
    name_lower = path.name.lower()
    return all(k.lower() in name_lower for k in keywords)

matching_files = [f for f in all_files if name_has_keywords(f, KEYWORDS)]
print(f"{len(matching_files)} files match {KEYWORDS}")

(Change the words or add more to get the filter you need.)


---

4.  Pick the most recently modified one

latest = max(matching_files, key=lambda f: f.stat().st_mtime)
print("Latest file:", latest.name)
print("Modified:", time.ctime(latest.stat().st_mtime))

.stat().st_mtime returns the epoch time (seconds since 1970-01-01).
max(..., key=...) grabs the path whose timestamp is greatest.


---

5.  Copy it to the destination

destination_path = DST_DIR / latest.name          # keep the same file name
shutil.copy2(latest, destination_path)            # copy2 preserves timestamps
print("Copied to:", destination_path)

Thatâ€™s the whole workflow in bite-size pieces.
Once each cell behaves as expected, youâ€™re ready for the one-shot function ðŸ‘‡.


---

6.  The full beginner-friendly function

from pathlib import Path
import shutil

def copy_latest_file(src_dir, dst_dir, keywords):
    """
    Search `src_dir` (incl. sub-folders) for the newest file whose *name*
    contains *all* `keywords` (case-insensitive).  Copy it into `dst_dir`
    and return the destination Path.

    Example
    -------
    copy_latest_file(
        r"C:\Data\Reports",                # source tree
        r"C:\Data\Latest",                 # destination folder
        keywords=["sales", "2025"]         # words that must appear in the file name
    )
    """
    src_dir = Path(src_dir)
    dst_dir = Path(dst_dir)
    dst_dir.mkdir(parents=True, exist_ok=True)

    # Collect candidate files
    def match(p):
        name = p.name.lower()
        return all(k.lower() in name for k in keywords)

    matches = [p for p in src_dir.rglob("*") if p.is_file() and match(p)]
    if not matches:
        raise FileNotFoundError(f"No files containing {keywords} found under {src_dir}")

    # Latest by modification time
    latest = max(matches, key=lambda p: p.stat().st_mtime)

    # Copy it
    target = dst_dir / latest.name
    shutil.copy2(latest, target)   # use copy2 to preserve metadata
    return target

How to use it

new_file = copy_latest_file(
    src_dir=r"C:\Data\Reports",
    dst_dir=r"C:\Data\Latest",
    keywords=["sales", "2025"]
)
print("âœ… Copied:", new_file)


---

What if I need to keep only the last N files in the destination?

Add two lines at the end of the function:

# --- optional clean-up: keep only N most recent files in dst_dir ---
    N = 3
    existing = sorted(dst_dir.glob("*"), key=lambda p: p.stat().st_mtime, reverse=True)
    for old in existing[N:]:
        old.unlink()                      # delete anything older than the N freshest


---

Why these libraries?

Library	Why we picked it

pathlib	Clear, cross-platform paths
shutil	Easy, reliable file copy
time	Only for human-readable timestamp printing in demos


Everything is in the Python standard libraryâ€”no extra installs required.
Happy automating!

