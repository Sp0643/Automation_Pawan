Below is a beginner-friendly, “build-it-as-you-go” walkthrough followed by the complete function.
Feel free to run each numbered cell in an interactive Python session (Jupyter, VS Code, or IDLE) to see what’s happening at every step.


---

1. Imports you’ll need

# 1️⃣  Core libraries
from pathlib import Path      # modern, object-oriented file paths
import shutil                 # for copying files
from typing import List       # for type hints (optional)


---

2. Gather every file under the source folder (recursively)

# 2️⃣  Replace this with your own folder
SRC_ROOT = Path(r"C:\path\to\source")

all_files = [p for p in SRC_ROOT.rglob("*") if p.is_file()]
print(f"Found {len(all_files)} files")

Path.rglob("*") walks all sub-directories automatically.
You should now see how many files were detected.


---

3. Keep only files whose names contain one (or more) keywords

# 3️⃣  Define ANY keywords you want to match in the filename
keywords = ["sales", "report", "2025"]

def has_keyword(path: Path, kw_list: List[str], case_sensitive=False) -> bool:
    name = path.name if case_sensitive else path.name.lower()
    kws  = kw_list         if case_sensitive else [k.lower() for k in kw_list]
    return any(kw in name for kw in kws)

filtered = [f for f in all_files if has_keyword(f, keywords)]
print(f"Matched {len(filtered)} files with keywords {keywords}")


---

4. Pick the most recently modified file from the filtered list

# 4️⃣  Use the file’s “last-modified” timestamp
latest_file = max(filtered, key=lambda p: p.stat().st_mtime, default=None)

if latest_file is None:
    raise FileNotFoundError("No files matched the given keywords.")
print(f"Newest file is: {latest_file}")


---

5. Copy it to the destination folder

# 5️⃣  Destination directory (will be created if missing)
DST_DIR = Path(r"C:\path\to\destination")
DST_DIR.mkdir(parents=True, exist_ok=True)

# Preserve original filename and metadata
copied_to = DST_DIR / latest_file.name
shutil.copy2(latest_file, copied_to)

print(f"Copied → {copied_to}")


---

6. (Optional) Keep only the N most recent files in the destination

def prune_destination(dest: Path, keep_last: int = 3):
    files = sorted(
        [p for p in dest.iterdir() if p.is_file()],
        key=lambda p: p.stat().st_mtime,
        reverse=True,
    )
    for old in files[keep_last:]:
        old.unlink()          # permanently delete
        print(f"Deleted old backup: {old}")

# Uncomment if you want this behaviour
# prune_destination(DST_DIR, keep_last=3)


---

7. Full function

Here’s the same logic wrapped in one tidy, reusable function:

from pathlib import Path
import shutil
from typing import List, Optional

def copy_latest_file(
    src_root: str | Path,
    dst_dir: str | Path,
    keywords: List[str],
    case_sensitive: bool = False,
    keep_last: Optional[int] = None,
) -> Path:
    """
    Find the newest file under `src_root` whose *filename* contains ANY of
    the given `keywords`, copy it into `dst_dir`, and (optionally) keep only
    the last `keep_last` files in that destination.

    Returns the Path of the copied file.
    """
    src_root = Path(src_root)
    dst_dir  = Path(dst_dir)
    dst_dir.mkdir(parents=True, exist_ok=True)

    # 1. Find all matching files
    matches = [
        p for p in src_root.rglob("*") if p.is_file()
        and (
            (set(k if case_sensitive else k.lower() for k in keywords)
             & {p.name}  # dummy to force evaluation
             or any((k if case_sensitive else k.lower()) in
                    (p.name if case_sensitive else p.name.lower())
                    for k in keywords))
        )
    ]
    if not matches:
        raise FileNotFoundError("No file found with the specified keywords.")

    # 2. Choose the newest
    latest = max(matches, key=lambda p: p.stat().st_mtime)

    # 3. Copy it
    dest_path = dst_dir / latest.name
    shutil.copy2(latest, dest_path)

    # 4. Optionally prune old copies
    if keep_last is not None:
        files = sorted(
            [f for f in dst_dir.iterdir() if f.is_file()],
            key=lambda p: p.stat().st_mtime,
            reverse=True,
        )
        for old in files[keep_last:]:
            old.unlink()

    return dest_path

Usage

dest = copy_latest_file(
    src_root=r"C:\Data",
    dst_dir=r"C:\Backup\Daily",
    keywords=["sales", ".xlsx"],
    keep_last=3,            # omit or set to None if you don’t want pruning
)
print("Latest file copied to:", dest)


---

Why this design is beginner-friendly

1. Pathlib everywhere – no back-slash headaches, clear methods (rglob, stem, suffix, etc.).


2. Step-by-step build – run each section, inspect variables, gain confidence.


3. Plain English docstring & comments – quickly recall what each piece does.


4. Optional clean-up – copy-paste the function even if you don’t need the pruning part.



You can now adapt the keyword list, source/destination folders, or the retention rule with a single line change. Happy coding!

Absolutely! Let's start from the very basics, so you understand what a function is, how it works, and how to build up gradually to a more complex one.


---

🔹 What is a Python Function?

A function is like a recipe. You give it some ingredients (called inputs or arguments), and it gives you a result (called output or return value).


---

✅ Step 1: Your First Function (Simple Addition)

def add_numbers(a, b):
    result = a + b
    return result

Explanation:

def means you're defining a function.

add_numbers is the name of the function.

a, b are inputs.

a + b adds the numbers.

return result gives the output.


Try it:

print(add_numbers(2, 3))  # Output: 5


---

✅ Step 2: Add a Message (More Friendly Output)

def greet_user(name):
    print("Hello, " + name + "!")

greet_user("Sohan")  # Output: Hello, Sohan!


---

✅ Step 3: A Function with Decision Making (if-else)

def check_even_or_odd(number):
    if number % 2 == 0:
        return "Even"
    else:
        return "Odd"

print(check_even_or_odd(4))  # Output: Even
print(check_even_or_odd(7))  # Output: Odd


---

✅ Step 4: A Slightly Complex One – Average of List

def calculate_average(numbers):
    total = sum(numbers)
    count = len(numbers)
    average = total / count
    return average

my_list = [10, 20, 30, 40]
print(calculate_average(my_list))  # Output: 25.0


---

✅ Step 5: Final: Build a Custom Function Together

Let’s say you want to:

Take a list of numbers.

Remove any negative numbers.

Square the remaining numbers.

Return the result.


def process_numbers(numbers):
    clean_numbers = []
    for num in numbers:
        if num >= 0:
            clean_numbers.append(num ** 2)
    return clean_numbers

sample = [1, -2, 3, -4, 5]
print(process_numbers(sample))  # Output: [1, 9, 25]


---

Would you like to now:

1. Try writing a function yourself and I’ll guide you?


2. Move to more complex logic like working with files, charts, or APIs?


3. Build something fun like a number guessing game or calculator?



Let me know your goal!




Below is a mini-lesson you can run step-by-step.
Each step adds one small idea; run it, inspect the output, and move on.
At the end you’ll see the same pieces put together as one tidy function.


---

0.  Imports we’ll need

from pathlib import Path        # modern, OS-independent path handling
import shutil                   # for copying files
import time                     # only for pretty-printing timestamps in this demo


---

1.  Point to your folders

# 👉 Change these to match your machine
SRC_DIR = Path(r"C:\Data\Reports")     # search starts here (all sub-folders included)
DST_DIR = Path(r"C:\Data\Latest")      # where the newest file will be copied

# Make sure the destination exists
DST_DIR.mkdir(parents=True, exist_ok=True)

Why Path instead of plain strings?
Path objects work the same on Windows, macOS, and Linux and give you handy methods like .rglob().


---

2.  Find all files under SRC_DIR

all_files = [f for f in SRC_DIR.rglob("*") if f.is_file()]
print(f"Found {len(all_files)} files")

What just happened?

.rglob("*") walks every sub-folder.

f.is_file() keeps regular files and skips directories.



---

3.  Filter by a keyword (or several)

KEYWORDS = ["sales", "2025"]   # match files whose *names* contain BOTH words

def name_has_keywords(path, keywords):
    name_lower = path.name.lower()
    return all(k.lower() in name_lower for k in keywords)

matching_files = [f for f in all_files if name_has_keywords(f, KEYWORDS)]
print(f"{len(matching_files)} files match {KEYWORDS}")

(Change the words or add more to get the filter you need.)


---

4.  Pick the most recently modified one

latest = max(matching_files, key=lambda f: f.stat().st_mtime)
print("Latest file:", latest.name)
print("Modified:", time.ctime(latest.stat().st_mtime))

.stat().st_mtime returns the epoch time (seconds since 1970-01-01).
max(..., key=...) grabs the path whose timestamp is greatest.


---

5.  Copy it to the destination

destination_path = DST_DIR / latest.name          # keep the same file name
shutil.copy2(latest, destination_path)            # copy2 preserves timestamps
print("Copied to:", destination_path)

That’s the whole workflow in bite-size pieces.
Once each cell behaves as expected, you’re ready for the one-shot function 👇.


---

6.  The full beginner-friendly function

from pathlib import Path
import shutil

def copy_latest_file(src_dir, dst_dir, keywords):
    """
    Search `src_dir` (incl. sub-folders) for the newest file whose *name*
    contains *all* `keywords` (case-insensitive).  Copy it into `dst_dir`
    and return the destination Path.

    Example
    -------
    copy_latest_file(
        r"C:\Data\Reports",                # source tree
        r"C:\Data\Latest",                 # destination folder
        keywords=["sales", "2025"]         # words that must appear in the file name
    )
    """
    src_dir = Path(src_dir)
    dst_dir = Path(dst_dir)
    dst_dir.mkdir(parents=True, exist_ok=True)

    # Collect candidate files
    def match(p):
        name = p.name.lower()
        return all(k.lower() in name for k in keywords)

    matches = [p for p in src_dir.rglob("*") if p.is_file() and match(p)]
    if not matches:
        raise FileNotFoundError(f"No files containing {keywords} found under {src_dir}")

    # Latest by modification time
    latest = max(matches, key=lambda p: p.stat().st_mtime)

    # Copy it
    target = dst_dir / latest.name
    shutil.copy2(latest, target)   # use copy2 to preserve metadata
    return target

How to use it

new_file = copy_latest_file(
    src_dir=r"C:\Data\Reports",
    dst_dir=r"C:\Data\Latest",
    keywords=["sales", "2025"]
)
print("✅ Copied:", new_file)


---

What if I need to keep only the last N files in the destination?

Add two lines at the end of the function:

# --- optional clean-up: keep only N most recent files in dst_dir ---
    N = 3
    existing = sorted(dst_dir.glob("*"), key=lambda p: p.stat().st_mtime, reverse=True)
    for old in existing[N:]:
        old.unlink()                      # delete anything older than the N freshest


---

Why these libraries?

Library	Why we picked it

pathlib	Clear, cross-platform paths
shutil	Easy, reliable file copy
time	Only for human-readable timestamp printing in demos


Everything is in the Python standard library—no extra installs required.
Happy automating!



Here’s a drop-in replacement for your current find_latest_file_and_copy that adds keyword filtering while staying almost identical to the code you’re already running.

import os
import shutil
from pathlib import Path
from typing import List, Union, Sequence

def find_latest_file_and_copy(
    source_dirs: Union[str, Path, Sequence[Union[str, Path]]],
    destination_dir: Union[str, Path],
    keywords: List[str] | None = None,
    case_sensitive: bool = False,
) -> Path:
    """
    Look through one *or* many source folders (recursively), find the most
    recently-modified file whose **name** contains ANY of `keywords`, and copy
    it to `destination_dir`.

    Parameters
    ----------
    source_dirs      : str | Path | list/tuple
        A single directory *or* an iterable of directories to search.
    destination_dir  : str | Path
        Where the newest matching file will be copied.
    keywords         : list[str] | None
        Text snippets to look for in the filename. If None or empty, every
        file counts.
    case_sensitive   : bool
        Match keywords with or without case-sensitivity.

    Returns
    -------
    pathlib.Path
        The full path of the file that was copied.
    """
    # ---- normalise inputs ---------------------------------------------------
    if isinstance(source_dirs, (str, Path)):
        source_dirs = [source_dirs]

    dest = Path(destination_dir)
    dest.mkdir(parents=True, exist_ok=True)

    # ---- keyword pre-processing --------------------------------------------
    if keywords:
        kws = keywords if case_sensitive else [k.lower() for k in keywords]
    else:
        kws = []   # treat as "no filtering"

    # ---- search for newest matching file ------------------------------------
    latest_file      = None
    latest_file_mtime = 0

    for src in source_dirs:
        for root, _, files in os.walk(src):
            for file in files:
                # ① keyword filter
                name_to_check = file if case_sensitive else file.lower()
                if kws and not any(kw in name_to_check for kw in kws):
                    continue  # skip non-matches

                # ② compare modification time
                file_path = os.path.join(root, file)
                try:
                    mtime = os.path.getmtime(file_path)
                except OSError:
                    continue  # ignore unreadable files

                if mtime > latest_file_mtime:
                    latest_file_mtime  = mtime
                    latest_file        = file_path

    # ---- copy result (if found) ---------------------------------------------
    if latest_file is None:
        raise FileNotFoundError("No file matched the given keywords.")

    dest_path = dest / Path(latest_file).name
    shutil.copy2(latest_file, dest_path)  # copy2 keeps timestamps/metadata
    print(f"Copied '{latest_file}'  →  '{dest_path}'")

    return dest_path


---

How to call it

# One directory
find_latest_file_and_copy(
    source_dirs=r"\\ent.wfb.bank.corp\WHLSDFS\Shared\Agency Services\Daily Reports",
    destination_dir=r"C:\Backups\Daily",
    keywords=["wip", "report"],   # match ANY of these
    case_sensitive=False,         # ignore case (default)
)

# Many directories
sources = [
    r"\\...Financial Cash Controls\...\2025",
    r"\\...Agency Servicing\VIP\ARCOE Recons\ATI 1007201",
    r"\\...MCCY Recon\2025",
]
find_latest_file_and_copy(
    source_dirs=sources,
    destination_dir=r"C:\Backups\Daily",
    keywords=[".xlsx", "wip"],     # e.g. only Excel WIP files
)

What changed compared to your original snippet?

Feature	Old version	New version

Keyword filter	✘	✔ keywords argument, case-toggle
Multiple source roots	✘ (single)	✔ source_dirs accepts list / tuple
Pathlib for destination	partial	full use for mkdir & return value
Type hints / docstring	minimal	expanded, beginner-friendly


Copy the function into your script/notebook, adjust the call as shown, and you’re done. Let me know if you’d like any extra tweaks (e.g. keeping only the last N backups in the destination).

What went wrong?
The | (pipe) syntax for “A or B” type hints only works in Python 3.10+.
Your notebook/kernel is on an older version (3.9 or earlier), so it raises:

TypeError: unsupported operand type(s) for |: '_GenericAlias' and 'NoneType'


---

2 quick ways to fix it

A. Keep your current Python and switch to Optional[...]

Replace every T | None with Optional[T] and import Optional from typing.

import os
import shutil
from pathlib import Path
from typing import List, Optional, Sequence, Union   # ← add Optional

def find_latest_file_and_copy(
    source_dirs: Union[str, Path, Sequence[Union[str, Path]]],
    destination_dir: Union[str, Path],
    keywords: Optional[List[str]] = None,            # ← use Optional
    case_sensitive: bool = False,
) -> Path:
    # ---------- normalise inputs ----------------------------
    if isinstance(source_dirs, (str, Path)):
        source_dirs = [source_dirs]

    dest = Path(destination_dir)
    dest.mkdir(parents=True, exist_ok=True)

    # ---------- keyword prep --------------------------------
    kws = []
    if keywords:
        kws = keywords if case_sensitive else [k.lower() for k in keywords]

    # ---------- find newest matching file -------------------
    latest_file = None
    latest_mtime = 0

    for src in source_dirs:
        for root, _, files in os.walk(src):
            for file in files:
                # keyword filter
                name = file if case_sensitive else file.lower()
                if kws and not any(kw in name for kw in kws):
                    continue

                fp = os.path.join(root, file)
                try:
                    mtime = os.path.getmtime(fp)
                except OSError:
                    continue

                if mtime > latest_mtime:
                    latest_mtime = mtime
                    latest_file  = fp

    if latest_file is None:
        raise FileNotFoundError("No file matched the given keywords.")

    # ---------- copy & return -------------------------------
    dest_path = dest / Path(latest_file).name
    shutil.copy2(latest_file, dest_path)
    print(f"Copied '{latest_file}' → '{dest_path}'")
    return dest_path

> That’s the only change—everything else keeps working exactly as before.




---

B. Upgrade your environment to Python 3.10+

If you’d like the modern | syntax (and other 3.10 perks), install / switch to a 3.10 or newer interpreter:

# Example for conda
conda create -n py310 python=3.10
conda activate py310
pip install notebook  # or jupyterlab / VS Code etc.

Then your original code compiles without edits.


---

TL;DR

Stay on 3.8/3.9 → change List[str] | None to Optional[List[str]].

Move to 3.10+ → keep the pipe syntax.


Pick whichever suits your setup and you’ll be good to go. Happy coding!

