Here’s a complete Python markdown version you can copy-paste directly into your Jupyter notebook to teach or reference all basic pandas.Series functions.


---

# 📘 Basic Functions in pandas.Series

## 📊 Structure & Type

```python
import pandas as pd

s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'])

type(s)          # Check type
len(s)           # Number of elements
s.shape          # Shape of the series
s.dtype          # Data type of the values
s.index          # Index labels
s.values         # Underlying numpy array


---

🔍 Data Inspection

s.head()         # First 5 elements
s.tail()         # Last 5 elements
s.sample(2)      # Random 2 elements
s.unique()       # Unique values
s.nunique()      # Number of unique values
s.value_counts() # Frequency count of values


---

📈 Statistical Summary

s.sum()          # Sum of values
s.mean()         # Mean (average)
s.median()       # Median value
s.mode()         # Most frequent value(s)
s.std()          # Standard deviation
s.min()          # Minimum value
s.max()          # Maximum value
s.describe()     # Statistical summary


---

🔤 Sorting & Indexing

s.sort_values()        # Sort by values
s.sort_index()         # Sort by index
s.reindex(['c', 'a', 'e', 'b', 'd'])  # Change order of index
s.reset_index()        # Reset index (returns DataFrame)


---

📌 Accessing Values

s['a']                 # Access by label
s[0]                   # Access by position
s.loc['b']             # Access by label using .loc
s.iloc[2]              # Access by position using .iloc


---

🔧 Data Transformation

s.apply(lambda x: x * 2)           # Apply a function
s.map({10: 100, 20: 200})          # Map using dictionary
s.replace(30, 300)                 # Replace value
s.astype(float)                    # Change data type


---

🧵 String Operations (only for string Series)

s_str = pd.Series(["apple", "banana", "cherry"])

s_str.str.upper()      # Convert to uppercase
s_str.str.contains('a')# Check for substring
s_str.str.len()        # Length of each string

---

Let me know if you want an exportable `.ipynb` notebook or want to add quiz/exercises with these!




# 📘 Basic Functions in pandas.Series

## 📊 Structure & Type
- **`type()`**: Returns the type of the Series object.
- **`len()`**: Returns the number of elements in the Series.
- **`.shape`**: Returns a tuple indicating the number of elements.
- **`.dtype`**: Returns the data type of the Series values.
- **`.index`**: Returns the index (labels) of the Series.
- **`.values`**: Returns the underlying NumPy array of values.

---

## 🔍 Data Inspection
- **`.head(n)`**: Returns the first `n` elements of the Series.
- **`.tail(n)`**: Returns the last `n` elements.
- **`.sample(n)`**: Returns a random sample of `n` elements.
- **`.unique()`**: Returns the unique values in the Series.
- **`.nunique()`**: Returns the number of unique elements.
- **`.value_counts()`**: Returns counts of unique values.

---

## 📈 Statistical Summary
- **`.sum()`**: Computes the sum of all elements.
- **`.mean()`**: Returns the average of the values.
- **`.median()`**: Returns the median value.
- **`.mode()`**: Returns the most frequent value(s).
- **`.std()`**: Returns the standard deviation.
- **`.min()`**: Returns the smallest value.
- **`.max()`**: Returns the largest value.
- **`.describe()`**: Generates summary statistics.

---

## 🔤 Sorting & Indexing
- **`.sort_values()`**: Sorts the Series by values.
- **`.sort_index()`**: Sorts the Series by index.
- **`.reindex()`**: Reorders the Series using a new index.
- **`.reset_index()`**: Resets the index, turning it into a column.

---

## 📌 Accessing Values
- **`[]`**: Access by label or position.
- **`.loc[]`**: Access by label.
- **`.iloc[]`**: Access by integer position.

---

## 🔧 Data Transformation
- **`.apply()`**: Applies a function to each element.
- **`.map()`**: Maps values using a function or dictionary.
- **`.replace()`**: Replaces values in the Series.
- **`.astype()`**: Converts Series to a specified data type.

---

## 🧵 String Operations (for object/string type)
- **`.str.upper()`**: Converts strings to uppercase.
- **`.str.contains()`**: Checks if each string contains a pattern.
- **`.str.len()`**: Computes the length of each string.




Certainly! Here's a single Python markdown block you can paste into a Jupyter Notebook Markdown cell. It contains clear and organized definitions of key pandas.Series functions, without code examples—perfect for learning or teaching:


---

# 📘 Basic Functions in pandas.Series

## 📊 Structure & Type
- **`type()`**: Returns the type of the Series object.
- **`len()`**: Returns the number of elements in the Series.
- **`.shape`**: Returns a tuple indicating the number of elements.
- **`.dtype`**: Returns the data type of the Series values.
- **`.index`**: Returns the index (labels) of the Series.
- **`.values`**: Returns the underlying NumPy array of values.

---

## 🔍 Data Inspection
- **`.head(n)`**: Returns the first `n` elements of the Series.
- **`.tail(n)`**: Returns the last `n` elements.
- **`.sample(n)`**: Returns a random sample of `n` elements.
- **`.unique()`**: Returns the unique values in the Series.
- **`.nunique()`**: Returns the number of unique elements.
- **`.value_counts()`**: Returns counts of unique values.

---

## 📈 Statistical Summary
- **`.sum()`**: Computes the sum of all elements.
- **`.mean()`**: Returns the average of the values.
- **`.median()`**: Returns the median value.
- **`.mode()`**: Returns the most frequent value(s).
- **`.std()`**: Returns the standard deviation.
- **`.min()`**: Returns the smallest value.
- **`.max()`**: Returns the largest value.
- **`.describe()`**: Generates summary statistics.

---

## 🔤 Sorting & Indexing
- **`.sort_values()`**: Sorts the Series by values.
- **`.sort_index()`**: Sorts the Series by index.
- **`.reindex()`**: Reorders the Series using a new index.
- **`.reset_index()`**: Resets the index, turning it into a column.

---

## 📌 Accessing Values
- **`[]`**: Access by label or position.
- **`.loc[]`**: Access by label.
- **`.iloc[]`**: Access by integer position.

---

## 🔧 Data Transformation
- **`.apply()`**: Applies a function to each element.
- **`.map()`**: Maps values using a function or dictionary.
- **`.replace()`**: Replaces values in the Series.
- **`.astype()`**: Converts Series to a specified data type.

---

## 🧵 String Operations (for object/string type)
- **`.str.upper()`**: Converts strings to uppercase.
- **`.str.contains()`**: Checks if each string contains a pattern.
- **`.str.len()`**: Computes the length of each string.


---

Let me know if you'd like a version with icons or emojis for better visual cues, or a companion code block version for hands-on practice.




Absolutely! Below is a well-organized Python markdown block for a Jupyter Notebook Markdown cell that lists top pandas data cleaning functions with concise definitions.

And after that, I’ve included a code example block for hands-on understanding. 👍


---

✅ Python Markdown Block (Paste into a Markdown Cell)

# 🧹 Data Cleaning Functions in pandas

## 🔍 Missing Values
- **`.isna()`**: Detects missing values (returns True for NaN).
- **`.notna()`**: Detects non-missing values (returns True where data is present).
- **`.fillna(value)`**: Fills missing values with a specified value.
- **`.dropna()`**: Drops rows (or columns) with missing values.

## 🧭 Duplicates
- **`.duplicated()`**: Returns a boolean Series indicating duplicate rows.
- **`.drop_duplicates()`**: Removes duplicate rows.

## 🧼 Replacing & Mapping
- **`.replace(old, new)`**: Replaces values throughout the DataFrame.
- **`.map()`**: Maps values using a function or dictionary (on Series).
- **`.astype(type)`**: Converts data type of a column.

## 🧹 Column & Row Management
- **`.drop(labels, axis)`**: Drops specified rows or columns.
- **`.rename()`**: Renames columns or indexes.
- **`.apply(func)`**: Applies a function across DataFrame/Series.

## 🕵️ Value Filtering & Validation
- **`.between()`**: Filters numeric values within a range.
- **`.clip(lower, upper)`**: Trims values outside of range.
- **`.where(condition)`**: Keeps values where condition is True, replaces others with NaN.


---

🧪 Code Example Block (Paste into a Code Cell)

import pandas as pd
import numpy as np

# Sample DataFrame
df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Alice', 'David', None],
    'Age': [25, np.nan, 25, 30, 22],
    'Score': [88, 92, 88, np.nan, 70]
})

# Detect missing values
print(df.isna())

# Drop rows with any missing values
cleaned_df = df.dropna()

# Fill missing age with average
df['Age'] = df['Age'].fillna(df['Age'].mean())

# Check for duplicates
print(df.duplicated())

# Drop duplicate rows
df = df.drop_duplicates()

# Replace specific value
df['Name'] = df['Name'].replace('Alice', 'Alicia')

# Drop column
df = df.drop(columns='Score')

# Convert Age to integer
df['Age'] = df['Age'].astype(int)

print(df)


---

Let me know if you'd like a quiz or exercise section added to reinforce these concepts!



# 🧹 Top Data Cleaning Functions in pandas (Training Reference)

This curated list covers the most commonly used functions for data cleaning in pandas, including missing values, duplicates, type conversions, and structural cleanup. Ideal for quick reference or as a checklist during preprocessing.

---

## ✅ Top Data Cleaning Functions in pandas

---

### 🔍 Handling Missing Values

- **`df.isna()`** – Detect missing values (NaNs)
- **`df.notna()`** – Detect non-missing values
- **`df.dropna()`** – Drop rows/columns with missing values
- **`df.fillna(value)`** – Fill missing values with a specified constant, method, or interpolation
- **`df.interpolate()`** – Fill missing values using interpolation

---

### 🧭 Handling Duplicates

- **`df.duplicated()`** – Identify duplicated rows
- **`df.drop_duplicates()`** – Remove duplicate rows

---

### 🔧 Data Replacement & Transformation

- **`df.replace(old, new)`** – Replace specific values
- **`df.map()`** – Map values using a dictionary or function (Series only)
- **`df.apply(func)`** – Apply a function across rows or columns
- **`df.applymap(func)`** – Apply a function element-wise (only for DataFrame)
- **`df.astype(type)`** – Convert data type of columns

---

### 🧹 Dropping & Renaming

- **`df.drop(labels, axis=0 or 1)`** – Drop specified rows or columns
- **`df.rename(columns={...})`** – Rename columns
- **`df.reset_index()`** – Reset the index to default integer values
- **`df.set_index('column')`** – Set a column as the new index

---

### 🧪 Filtering & Clipping

- **`df.where(condition)`** – Keep values that meet condition, replace others with NaN
- **`df.mask(condition)`** – Opposite of `where()`, replaces values that meet condition
- **`df.clip(lower, upper)`** – Limit values within a range
- **`df.between(a, b)`** – Check if values fall within range `a` and `b`

---


Great! Let’s extend your story with MultiIndexing that includes categories like Vegetables and Fruits — and then show how a smart shopkeeper machine (your Python code) can generate a mixed-category bill.


---

🧺 7️⃣ MultiIndex Example with Categories: "Vegetables" and "Fruits"

import pandas as pd

# Define categories and items
categories = ["Vegetable", "Vegetable", "Vegetable", "Fruit", "Fruit", "Fruit"]
items = ["Onion", "Potato", "Brinjal", "Apple", "Banana", "Orange"]
prices = [50, 30, 45, 100, 25, 60]

# Create MultiIndex
multi_index = pd.MultiIndex.from_arrays([categories, items], names=["Category", "Item"])

# Create Series
shop_series = pd.Series(prices, index=multi_index)
print("🧾 Price Register:\n", shop_series)


---

🧪 8️⃣ Creating a Mixed Bill (Veg + Fruit Purchase)

# Create a new bill: 2 Potatoes, 1 Brinjal, 3 Apples, 5 Bananas
my_bill = (
    shop_series[("Vegetable", "Potato")] * 2 +
    shop_series[("Vegetable", "Brinjal")] * 1 +
    shop_series[("Fruit", "Apple")] * 3 +
    shop_series[("Fruit", "Banana")] * 5
)

print("\n💰 Total Bill for Mixed Items:", my_bill)


---

✅ Output Sample:

🧾 Price Register:
Category   Item   
Vegetable  Onion      50
           Potato     30
           Brinjal    45
Fruit      Apple     100
           Banana     25
           Orange     60
dtype: int64

💰 Total Bill for Mixed Items: 2*30 + 1*45 + 3*100 + 5*25 = 555


---

💡 Bonus Explanation for Learners:

MultiIndex is like organizing shelves in a store: first by Category, then by Item.

It helps in structuring data hierarchically.

This is useful in real-life scenarios like:

Supermarket billing systems

Financial category breakdowns

Sensor data by location and time




---

Would you like:

A .ipynb notebook with this entire storyline + explanations?

Quiz or exercises for learners to try creating their own bills?


Let me know and I’ll generate it for you!






import pandas as pd

# Define data
items_with_category = [
    ("Vegetable", "Onion"),
    ("Vegetable", "Potato"),
    ("Vegetable", "Brinjal"),
    ("Fruit", "Apple"),
    ("Fruit", "Banana"),
    ("Fruit", "Orange")
]
prices = [50, 30, 45, 100, 25, 60]

# Create MultiIndex Series
shop_series = pd.Series(prices, index=pd.MultiIndex.from_tuples(items_with_category, names=["Category", "Item"]))

# 🔍 Accessing price of Onion under Vegetable using tuple
onion_price = shop_series[("Vegetable", "Onion")]
print("Price of Vegetable - Onion:", onion_price)



Sure! Here's the entire explanation formatted as Python Markdown (ready to use in a Jupyter Notebook):


---

## ✅ Key Properties of NumPy Arrays

1. **Homogeneous Data**: All elements must be of the same data type (e.g., int, float).
2. **Fixed Size**: Once created, the size (shape) of a NumPy array cannot be changed.
3. **Multidimensional Support**: Supports 1D, 2D, 3D or higher-dimensional arrays.
4. **Vectorized Operations**: Fast mathematical operations on whole arrays without loops.
5. **Indexing & Slicing**: Similar to Python lists but more powerful for multi-dimensional data.
6. **Memory Efficient**: Consumes less memory and is faster for numerical computations.
7. **Integrated with Pandas**: NumPy arrays are the foundation of Pandas Series and DataFrames.

---

## 📌 Difference: NumPy Array vs. Pandas Series

| Feature               | NumPy Array                             | Pandas Series                              |
|----------------------|------------------------------------------|---------------------------------------------|
| Data Type            | Homogeneous                              | Heterogeneous allowed (but uncommon)        |
| Axis Labels          | No axis labels (only integer indices)    | Has axis labels (like dictionary keys)      |
| Built-in Index       | No                                        | Yes                                         |
| Use Case             | Math, vectorized computation              | Labeled 1D data, easier data manipulation    |
| Missing Data Support | No (use `np.nan`, but tricky)             | Yes (handles `NaN` more gracefully)         |

---

## 💡 Example: NumPy vs Pandas Series

```python
import numpy as np
import pandas as pd

# NumPy array
np_array = np.array([10, 20, 30])

# Pandas Series (from NumPy array)
series = pd.Series(np_array, index=["a", "b", "c"])

print("NumPy Array:", np_array)
print("Pandas Series:\n", series)


---

✅ Summary for Teaching

> "NumPy arrays are great when we want compact, fast numeric processing. But when we want labels, indexing, and data analysis, Pandas Series (or DataFrames) are more powerful. Pandas is built on top of NumPy — so we often convert NumPy arrays into Series or DataFrames when needed."



---

Let me know if you’d like a similar block for **Lists of Dictionaries** or **Dictionaries of Lists** too!




Absolutely! Here's the full explanation formatted as Python Markdown – perfect for use in a Jupyter Notebook:


---

## ✅ Difference Between Python List vs NumPy Array

| Feature                     | Python List                                | NumPy Array (`np.array`)                       |
|----------------------------|---------------------------------------------|------------------------------------------------|
| **Data Type**              | Can store mixed types (int, str, float)     | Homogeneous (all elements must be same type)   |
| **Performance**            | Slower for numerical operations             | Much faster due to internal C implementation   |
| **Memory Efficiency**      | Uses more memory                            | Compact and memory efficient                   |
| **Operations**             | No built-in vector operations               | Supports vectorized operations (e.g., `+`, `*`)|
| **Dimensionality**         | 1D only (nested lists for more)             | Supports multi-dimensional arrays (1D, 2D, ...)|
| **Functionality**          | General-purpose data container              | Optimized for mathematical & scientific computing|
| **Broadcasting**           | Not supported                               | Supported                                      |
| **Slicing & Indexing**     | Limited                                     | Advanced indexing and slicing                  |

---

## 🧪 Example

```python
import numpy as np

# Python List
py_list = [1, 2, 3]
print("Python List:", py_list)

# NumPy Array
np_array = np.array([1, 2, 3])
print("NumPy Array:", np_array)

# Try addition
# print(py_list + 1)  # ❌ Error: unsupported operand
print("NumPy Array + 1:", np_array + 1)  # ✅ Vectorized addition


---

🔑 Key Takeaway

> Use Python lists for general-purpose storage and mixed data types.
Use NumPy arrays for efficient mathematical operations and large-scale numerical data.



---

Let me know if you'd like markdowns for other comparisons like **Pandas Series vs NumPy Array** or **DataFrame vs Dictionary**!




# Basic Functions in pandas.DataFrame

---

## 🏗️ Structure & Type

- `type(df)` : Returns the type of the DataFrame object.  
- `len(df)` : Returns the number of rows in the DataFrame.  
- `df.shape` : Returns a tuple representing (rows, columns).  
- `df.dtypes` : Returns the data types of each column.  
- `df.columns` : Returns the column labels.  
- `df.index` : Returns the row index (labels).  
- `df.values` : Returns the underlying NumPy array of values.  

---

## 🔍 Data Inspection

- `df.head(n)` : Returns the first `n` rows of the DataFrame.  
- `df.tail(n)` : Returns the last `n` rows.  
- `df.sample(n)` : Returns a random sample of `n` rows.  
- `df.info()` : Displays index, column names, non-null counts, and dtypes.  
- `df.describe()` : Returns summary statistics for numeric columns.  
- `df.isnull()` : Detects missing (NaN) values.  
- `df.notnull()` : Detects non-missing values.  

---

## 🔁 Data Cleaning & Transformation

- `df.drop(columns=['col1'])` : Drops specified columns.  
- `df.dropna()` : Drops rows with any NaN values.  
- `df.fillna(value)` : Fills NaN values with a specified value.  
- `df.rename(columns={'old':'new'})` : Renames columns.  
- `df.astype({'col': type})` : Changes data type of a column.  
- `df.replace(to_replace, value)` : Replaces values in the DataFrame.

---

## 📊 Statistical Summary

- `df.mean()` : Returns mean of numeric columns.  
- `df.median()` : Returns median of numeric columns.  
- `df.std()` : Returns standard deviation.  
- `df.min()` / `df.max()` : Returns min or max values.  
- `df.sum()` : Returns column-wise sum.  
- `df.corr()` : Returns correlation matrix.  
- `df.nunique()` : Returns number of unique values per column.  
- `df.value_counts()` : Used on Series (e.g., `df['col'].value_counts()`).

---

✅ These functions form the foundation for exploring and manipulating tabular data using pandas DataFrames.