

It looks like your MS Access SQL query has some formatting and syntax issues that need correction before we can convert it to IBM DB2 SQL.


---

Issues in the Query

1. Syntax Errors and Typos:

Some column and table names are incorrectly formatted (e.g., RIMTHAΑΣ, RIMTΗΑΣ).

10 appears in the SELECT clause without an alias.

CONTRACT ID-RIMTHAL ASSET.CONTRACT (0) is incorrectly written.

Missing aliases and incorrect brackets/parentheses.



2. INTO (Dorrie A Asset FROM Issue:

In MS Access, SELECT INTO is used for creating a new table.

In DB2, INSERT INTO should be used instead.



3. Joins Need Correction:

The join conditions are not properly formatted.



4. WHERE Clause Issues:

WHERE RIMTHAI CONTRACT.CONTRACT STATUS)-"A") is incorrect.

Correct format: WHERE RIMTHAI_CONTRACT.CONTRACT_STATUS = 'A' (DB2 uses = instead of -).





---

Corrected MS Access SQL

If the goal is to create a new table

SELECT 
    RIMTHAI_ASSET.CUSTOMER_NBR, 
    RIMTHAI_ASSET.CONTRACT_ID, 
    RIMTHAI_ASSET.ASSET_NBR, 
    RIMTHAI_COMPANY.COMPANY_NM, 
    RIMTHAI_COMPANY.COMP_OWN_CD, 
    RIMTHAI_CONTRACT.ACCT_PLAN_ID, 
    RIMTHAI_CONTRACT.CONTRACT_BAL, 
    RIMTHAI_CONTRACT.TOTAL_RENT, 
    RIMTHAI_COMPANY.COST_CENTER_CD, 
    RIMTHAI_CONTRACT.BRANCH_CO_NBR
INTO Dorrie_A_Asset  -- Creates a new table in MS Access
FROM 
    (RIMTHAI_CONTRACT 
    INNER JOIN RIMTHAI_COMPANY 
    ON RIMTHAI_CONTRACT.BRANCH_CO_NBR = RIMTHAI_COMPANY.COMPANY_NBR) 
    INNER JOIN RIMTHAI_ASSET 
    ON (RIMTHAI_CONTRACT.CONTRACT_ID = RIMTHAI_ASSET.CONTRACT_ID 
    AND RIMTHAI_CONTRACT.CUSTOMER_NBR = RIMTHAI_ASSET.CUSTOMER_NBR)
WHERE 
    RIMTHAI_CONTRACT.CONTRACT_STATUS = 'A' 
    AND RIMTHAI_ASSET.ASSET_STATUS = 'A'
GROUP BY 
    RIMTHAI_ASSET.CUSTOMER_NBR, 
    RIMTHAI_ASSET.CONTRACT_ID, 
    RIMTHAI_ASSET.ASSET_NBR, 
    RIMTHAI_COMPANY.COMPANY_NM, 
    RIMTHAI_COMPANY.COMP_OWN_CD, 
    RIMTHAI_CONTRACT.ACCT_PLAN_ID, 
    RIMTHAI_CONTRACT.CONTRACT_BAL, 
    RIMTHAI_CONTRACT.TOTAL_RENT, 
    RIMTHAI_COMPANY.COST_CENTER_CD, 
    RIMTHAI_CONTRACT.BRANCH_CO_NBR;


---

DB2 Equivalent Query

If the goal is to insert data into an existing table

INSERT INTO Dorrie_A_Asset ( 
    CUSTOMER_NBR, CONTRACT_ID, ASSET_NBR, COMPANY_NM, COMP_OWN_CD, 
    ACCT_PLAN_ID, CONTRACT_BAL, TOTAL_RENT, COST_CENTER_CD, BRANCH_CO_NBR
)
SELECT 
    RIMTHAI_ASSET.CUSTOMER_NBR, 
    RIMTHAI_ASSET.CONTRACT_ID, 
    RIMTHAI_ASSET.ASSET_NBR, 
    RIMTHAI_COMPANY.COMPANY_NM, 
    RIMTHAI_COMPANY.COMP_OWN_CD, 
    RIMTHAI_CONTRACT.ACCT_PLAN_ID, 
    RIMTHAI_CONTRACT.CONTRACT_BAL, 
    RIMTHAI_CONTRACT.TOTAL_RENT, 
    RIMTHAI_COMPANY.COST_CENTER_CD, 
    RIMTHAI_CONTRACT.BRANCH_CO_NBR
FROM 
    RIMTHAI_CONTRACT 
    INNER JOIN RIMTHAI_COMPANY 
    ON RIMTHAI_CONTRACT.BRANCH_CO_NBR = RIMTHAI_COMPANY.COMPANY_NBR
    INNER JOIN RIMTHAI_ASSET 
    ON RIMTHAI_CONTRACT.CONTRACT_ID = RIMTHAI_ASSET.CONTRACT_ID 
    AND RIMTHAI_CONTRACT.CUSTOMER_NBR = RIMTHAI_ASSET.CUSTOMER_NBR
WHERE 
    RIMTHAI_CONTRACT.CONTRACT_STATUS = 'A' 
    AND RIMTHAI_ASSET.ASSET_STATUS = 'A';


---

Key Differences in DB2 Version

1. INSERT INTO Instead of SELECT INTO

MS Access: SELECT ... INTO table_name

DB2: Use INSERT INTO table_name SELECT ...



2. Joins Format

MS Access requires extra parentheses in multi-table joins.

DB2 follows ANSI SQL and does not require parentheses.



3. Data Type Handling

MS Access: Uses TEXT, MEMO, YES/NO for text and boolean values.

DB2: Uses VARCHAR, CLOB, and BOOLEAN or SMALLINT.



4. String Literals in WHERE Clause

MS Access: Uses double quotes ("A")

DB2: Uses single quotes ('A')





---

Final Steps for Migration

1. Verify Column Names

Ensure that the column names match exactly in DB2.

Example: CUSTOMER_NBR vs. CUSTOMER_NBR_ (check for unintended underscores or typos).


2. Create Table in DB2 (if it doesn't exist)

CREATE TABLE Dorrie_A_Asset (
    CUSTOMER_NBR VARCHAR(20),
    CONTRACT_ID VARCHAR(20),
    ASSET_NBR VARCHAR(20),
    COMPANY_NM VARCHAR(100),
    COMP_OWN_CD VARCHAR(10),
    ACCT_PLAN_ID VARCHAR(20),
    CONTRACT_BAL DECIMAL(15,2),
    TOTAL_RENT DECIMAL(15,2),
    COST_CENTER_CD VARCHAR(20),
    BRANCH_CO_NBR VARCHAR(20)
);

3. Execute Query in Python Using pyodbc

import pyodbc

conn = pyodbc.connect("DSN=mydsn;UID=user;PWD=password")
cursor = conn.cursor()

insert_query = """
INSERT INTO Dorrie_A_Asset (CUSTOMER_NBR, CONTRACT_ID, ASSET_NBR, COMPANY_NM, COMP_OWN_CD, 
    ACCT_PLAN_ID, CONTRACT_BAL, TOTAL_RENT, COST_CENTER_CD, BRANCH_CO_NBR)
SELECT 
    RIMTHAI_ASSET.CUSTOMER_NBR, 
    RIMTHAI_ASSET.CONTRACT_ID, 
    RIMTHAI_ASSET.ASSET_NBR, 
    RIMTHAI_COMPANY.COMPANY_NM, 
    RIMTHAI_COMPANY.COMP_OWN_CD, 
    RIMTHAI_CONTRACT.ACCT_PLAN_ID, 
    RIMTHAI_CONTRACT.CONTRACT_BAL, 
    RIMTHAI_CONTRACT.TOTAL_RENT, 
    RIMTHAI_COMPANY.COST_CENTER_CD, 
    RIMTHAI_CONTRACT.BRANCH_CO_NBR
FROM RIMTHAI_CONTRACT 
INNER JOIN RIMTHAI_COMPANY ON RIMTHAI_CONTRACT.BRANCH_CO_NBR = RIMTHAI_COMPANY.COMPANY_NBR
INNER JOIN RIMTHAI_ASSET 
    ON RIMTHAI_CONTRACT.CONTRACT_ID = RIMTHAI_ASSET.CONTRACT_ID 
    AND RIMTHAI_CONTRACT.CUSTOMER_NBR = RIMTHAI_ASSET.CUSTOMER_NBR
WHERE RIMTHAI_CONTRACT.CONTRACT_STATUS = 'A' 
    AND RIMTHAI_ASSET.ASSET_STATUS = 'A';
"""

cursor.execute(insert_query)
conn.commit()
conn.close()


---

Summary

Fixed syntax errors in MS Access query.

Converted the query to DB2 SQL (ANSI SQL standard).

Used INSERT INTO instead of SELECT INTO.

Provided a Python pyodbc example to execute the query.


Let me know if you encounter any errors while running this in DB2!















Your queries appear to be written in MS Access SQL and need to be translated into IBM Db2 SQL for proper execution. Below is a breakdown of each query along with an explanation and its equivalent Db2 SQL.


---

1️⃣ Creating a Table with Aggregated Data

MS Access Query:

SELECT 
    Count([Dorrie A Asset].ASSET_NBR) AS CountOfASSET_NBR, 
    [Dorrie A Asset].COMPANY_NM, 
    [Dorrie A Asset].COMP_OWN_CD, 
    [Dorrie A Asset].ACCT_PLAN_ID, 
    [Dorrie A Asset].CONTRACT_BAL, 
    [Dorrie A Asset].TOTAL_RENT, 
    [Dorrie A Asset].COST_CENTER_CD AS [AU Number], 
    [Dorrie A Asset].BRANCH_CO_NBR 
INTO [Dorrie A Asset2]
FROM [Dorrie A Asset]
GROUP BY 
    [Dorrie A Asset].CUSTOMER_NBR, 
    [Dorrie A Asset].CONTRACT_ID, 
    [Dorrie A Asset].COMPANY_NM, 
    [Dorrie A Asset].COMP_OWN_CD, 
    [Dorrie A Asset].ACCT_PLAN_ID, 
    [Dorrie A Asset].CONTRACT_BAL, 
    [Dorrie A Asset].TOTAL_RENT, 
    [Dorrie A Asset].COST_CENTER_CD, 
    [Dorrie A Asset].BRANCH_CO_NBR;

Db2 Equivalent:

CREATE TABLE "Dorrie_A_Asset2" AS 
(
    SELECT 
        COUNT("ASSET_NBR") AS CountOfASSET_NBR, 
        "COMPANY_NM", 
        "COMP_OWN_CD", 
        "ACCT_PLAN_ID", 
        "CONTRACT_BAL", 
        "TOTAL_RENT", 
        "COST_CENTER_CD" AS "AU Number", 
        "BRANCH_CO_NBR"
    FROM "Dorrie_A_Asset"
    GROUP BY 
        "CUSTOMER_NBR", 
        "CONTRACT_ID", 
        "COMPANY_NM", 
        "COMP_OWN_CD", 
        "ACCT_PLAN_ID", 
        "CONTRACT_BAL", 
        "TOTAL_RENT", 
        "COST_CENTER_CD", 
        "BRANCH_CO_NBR"
) WITH NO DATA;

INSERT INTO "Dorrie_A_Asset2" 
SELECT 
    COUNT("ASSET_NBR"), 
    "COMPANY_NM", 
    "COMP_OWN_CD", 
    "ACCT_PLAN_ID", 
    "CONTRACT_BAL", 
    "TOTAL_RENT", 
    "COST_CENTER_CD", 
    "BRANCH_CO_NBR"
FROM "Dorrie_A_Asset"
GROUP BY 
    "CUSTOMER_NBR", 
    "CONTRACT_ID", 
    "COMPANY_NM", 
    "COMP_OWN_CD", 
    "ACCT_PLAN_ID", 
    "CONTRACT_BAL", 
    "TOTAL_RENT", 
    "COST_CENTER_CD", 
    "BRANCH_CO_NBR";


---

2️⃣ Updating AU Number Based on Conditions

MS Access Query:

UPDATE [Dorrie A Asset2] 
SET [AU Number] = "0" 
WHERE [BRANCH_CO_NBR] = "70";

Db2 Equivalent:

UPDATE "Dorrie_A_Asset2" 
SET "AU Number" = '0' 
WHERE "BRANCH_CO_NBR" = '70';

MS Access Query:

UPDATE [Dorrie A Asset2] 
SET [AU Number] = "No AU Nbr" 
WHERE [BRANCH_CO_NBR] IN ("55", "60", "65", "66", "67", "80", "85", "90");

Db2 Equivalent:

UPDATE "Dorrie_A_Asset2" 
SET "AU Number" = 'No AU Nbr' 
WHERE "BRANCH_CO_NBR" IN ('55', '60', '65', '66', '67', '80', '85', '90');


---

3️⃣ Creating Another Aggregated Table

MS Access Query:

SELECT 
    First([Dorrie A Asset2].ACCT_PLAN_ID) AS FirstOfACCT_PLAN_ID, 
    [Dorrie A Asset2].CUSTOMER_NBR, 
    [Dorrie A Asset2].COMP_OWN_CD, 
    [Dorrie A Asset2].COMPANY_NM, 
    Count([Dorrie A Asset2].CONTRACT_ID) AS CountOfCONTRACT_ID, 
    Sum([Dorrie A Asset2].CountOfASSET_NBR) AS SumOfCountOfASSET_NBR, 
    Sum([Dorrie A Asset2].CONTRACT_BAL) AS SumOfCONTRACT_BAL, 
    Sum([Dorrie A Asset2].TOTAL_RENT) AS SumOfTOTAL_RENT 
INTO [Dorrie A Asset3]
FROM [Dorrie A Asset2]
GROUP BY 
    [Dorrie A Asset2].CUSTOMER_NBR, 
    [Dorrie A Asset2].COMP_OWN_CD, 
    [Dorrie A Asset2].COMPANY_NM
ORDER BY First([Dorrie A Asset2].ACCT_PLAN_ID);

Db2 Equivalent:

CREATE TABLE "Dorrie_A_Asset3" AS 
(
    SELECT 
        MIN("ACCT_PLAN_ID") AS FirstOfACCT_PLAN_ID, 
        "CUSTOMER_NBR", 
        "COMP_OWN_CD", 
        "COMPANY_NM", 
        COUNT("CONTRACT_ID") AS CountOfCONTRACT_ID, 
        SUM("CountOfASSET_NBR") AS SumOfCountOfASSET_NBR, 
        SUM("CONTRACT_BAL") AS SumOfCONTRACT_BAL, 
        SUM("TOTAL_RENT") AS SumOfTOTAL_RENT 
    FROM "Dorrie_A_Asset2"
    GROUP BY "CUSTOMER_NBR", "COMP_OWN_CD", "COMPANY_NM"
) WITH NO DATA;

INSERT INTO "Dorrie_A_Asset3" 
SELECT 
    MIN("ACCT_PLAN_ID"), 
    "CUSTOMER_NBR", 
    "COMP_OWN_CD", 
    "COMPANY_NM", 
    COUNT("CONTRACT_ID"), 
    SUM("CountOfASSET_NBR"), 
    SUM("CONTRACT_BAL"), 
    SUM("TOTAL_RENT")
FROM "Dorrie_A_Asset2"
GROUP BY "CUSTOMER_NBR", "COMP_OWN_CD", "COMPANY_NM";


---

4️⃣ Updating Company Names

MS Access Query:

UPDATE [Dorrie A Asset3] 
SET [COMPANY_NM] = "RICOH" 
WHERE [COMP_OWN_CD] = "IKON";

Db2 Equivalent:

UPDATE "Dorrie_A_Asset3" 
SET "COMPANY_NM" = 'RICOH' 
WHERE "COMP_OWN_CD" = 'IKON';

MS Access Query:

UPDATE [Dorrie A Asset3] 
SET [COMPANY_NM] = "WELLS FARGO" 
WHERE [COMP_OWN_CD] = "IFS";

Db2 Equivalent:

UPDATE "Dorrie_A_Asset3" 
SET "COMPANY_NM" = 'WELLS FARGO' 
WHERE "COMP_OWN_CD" = 'IFS';


---

5️⃣ Inserting Final Aggregated Data

MS Access Query:

INSERT INTO Counts 
    ([report ran], COMPANY_NM, FirstOfACCT_PLAN_ID, [# Customers], [# Contracts], [# Assets], [$ GRI])
SELECT 
    Now() AS [report ran], 
    [Dorrie A Asset3].COMPANY_NM, 
    [Dorrie A Asset3].FirstOfACCT_PLAN_ID, 
    Count([Dorrie A Asset3].CUSTOMER_NBR) AS [# Customers], 
    Sum([Dorrie A Asset3].CountOfCONTRACT_ID) AS [# Contracts], 
    Sum([Dorrie A Asset3].SumOfCountOfASSET_NBR) AS [# Assets], 
    Sum([Dorrie A Asset3].SumOfTOTAL_RENT) AS SumOfSumOfTOTAL_RENT
FROM [Dorrie A Asset3]
GROUP BY Now(), [Dorrie A Asset3].COMPANY_NM, [Dorrie A Asset3].FirstOfACCT_PLAN_ID
ORDER BY [Dorrie A Asset3].COMPANY_NM, [Dorrie A Asset3].FirstOfACCT_PLAN_ID;

Db2 Equivalent:

INSERT INTO "Counts" 
    ("report_ran", "COMPANY_NM", "FirstOfACCT_PLAN_ID", "# Customers", "# Contracts", "# Assets", "$ GRI")
SELECT 
    CURRENT_TIMESTAMP AS "report_ran", 
    "COMPANY_NM", 
    "FirstOfACCT_PLAN_ID", 
    COUNT("CUSTOMER_NBR"), 
    SUM("CountOfCONTRACT_ID"), 
    SUM("SumOfCountOfASSET_NBR"), 
    SUM("SumOfTOTAL_RENT")
FROM "Dorrie_A_Asset3"
GROUP BY CURRENT_TIMESTAMP, "COMPANY_NM", "FirstOfACCT_PLAN_ID";

Would you like this in a Python script? 🚀




Since you don't have write access, you can use Common Table Expressions (CTEs) or Derived Tables (Subqueries) instead of temporary tables to structure your query.

Approach:

1. Use a CTE (WITH statement) to create a temporary result set in memory.


2. Use a subquery (SELECT ... FROM (...) AS subquery) if CTEs aren't supported in your environment.




---

Solution Using a CTE

Try modifying your query to use a CTE instead of inserting into a table:

WITH ASSET_DATA AS (
    SELECT 
        RIMTHAI_ASSET.CUSTOMER_NBR,
        RIMTHAI_ASSET.CONTRACT_ID,
        RIMTHAI_ASSET.ASSET_NBR,
        RIMTHAI_COMPANY.COMPANY_NBR,
        RIMTHAI_COMPANY.COMP_COMP_CD,
        RIMTHAI_CONTRACT.ACCT_PLAN_ID,
        RIMTHAI_CONTRACT.CONTRACT_BAL,
        RIMTHAI_CONTRACT.TOTAL_RENT,
        RIMTHAI_COMPANY.COST_CENTER_CD,
        RIMTHAI_CONTRACT.BRANCH_CO_NBR
    FROM 
        RIMTHAI_CONTRACT
    INNER JOIN RIMTHAI_COMPANY
        ON RIMTHAI_CONTRACT.BRANCH_CO_NBR = RIMTHAI_COMPANY.COMPANY_NBR
    INNER JOIN RIMTHAI_ASSET
        ON RIMTHAI_CONTRACT.CONTRACT_ID = RIMTHAI_ASSET.CONTRACT_ID
        AND RIMTHAI_CONTRACT.CUSTOMER_NBR = RIMTHAI_ASSET.CUSTOMER_NBR
    WHERE 
        RIMTHAI_CONTRACT.CONTRACT_STATUS = 'A'
        AND RIMTHAI_ASSET.ASSET_STATUS = 'A'
)
SELECT * FROM ASSET_DATA;


---

Alternative Using a Derived Table (Subquery)

If CTEs are not supported, use a subquery instead:

SELECT * FROM (
    SELECT 
        RIMTHAI_ASSET.CUSTOMER_NBR,
        RIMTHAI_ASSET.CONTRACT_ID,
        RIMTHAI_ASSET.ASSET_NBR,
        RIMTHAI_COMPANY.COMPANY_NBR,
        RIMTHAI_COMPANY.COMP_COMP_CD,
        RIMTHAI_CONTRACT.ACCT_PLAN_ID,
        RIMTHAI_CONTRACT.CONTRACT_BAL,
        RIMTHAI_CONTRACT.TOTAL_RENT,
        RIMTHAI_COMPANY.COST_CENTER_CD,
        RIMTHAI_CONTRACT.BRANCH_CO_NBR
    FROM 
        RIMTHAI_CONTRACT
    INNER JOIN RIMTHAI_COMPANY
        ON RIMTHAI_CONTRACT.BRANCH_CO_NBR = RIMTHAI_COMPANY.COMPANY_NBR
    INNER JOIN RIMTHAI_ASSET
        ON RIMTHAI_CONTRACT.CONTRACT_ID = RIMTHAI_ASSET.CONTRACT_ID
        AND RIMTHAI_CONTRACT.CUSTOMER_NBR = RIMTHAI_ASSET.CUSTOMER_NBR
    WHERE 
        RIMTHAI_CONTRACT.CONTRACT_STATUS = 'A'
        AND RIMTHAI_ASSET.ASSET_STATUS = 'A'
) AS ASSET_DATA;


---

Why This Works

CTEs (WITH statement) allow you to store the query result in memory and use it multiple times in the main query.

Derived Tables (Subqueries) let you use the result directly in a SELECT statement without creating a physical table.


This should allow you to proceed without needing write access. Let me know if you need further modifications!

